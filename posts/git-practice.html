<!DOCTYPE html><html lang="zh-Hans"><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="baidu-site-verification" content="cbUbgjjdru"/><meta name="generator" content="Next.js"/><link href="https://fonts.googleapis.com/css?family=Chelsea+Market:400" rel="stylesheet"/><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@300;400;500&amp;display=swap" rel="stylesheet"/><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/><script src="https://cdn.bootcdn.net/ajax/libs/react/16.13.1/umd/react.production.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/react-dom/16.13.1/umd/react-dom.production.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script><script src="/_.v1.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Git操作实践 - kiyak</title><link rel="preload" href="/_next/static/css/7af46002.794d2e46.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7af46002.794d2e46.chunk.css" data-n-g=""/><link rel="preload" href="/_next/static/css/189f372a1a09b44bc5ee9e8694cd22967121ee9f_CSS.48deeafe.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/189f372a1a09b44bc5ee9e8694cd22967121ee9f_CSS.48deeafe.chunk.css" data-n-g=""/><link rel="preload" href="/_next/static/css/712a84a73acf62bf26290958298b2566586e7dd8_CSS.77aeb35e.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/712a84a73acf62bf26290958298b2566586e7dd8_CSS.77aeb35e.chunk.css" data-n-g=""/><link rel="preload" href="/_next/static/css/93b2fd6e127d30331b61cfd2f04634ca05024a66_CSS.c9bcc403.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/93b2fd6e127d30331b61cfd2f04634ca05024a66_CSS.c9bcc403.chunk.css" data-n-g=""/><link rel="preload" href="/_next/static/css/styles.a71acdf5.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/styles.a71acdf5.chunk.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8a4b9c7b11a9228b425c7a73cade1154f2ca061e_CSS.0b204744.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8a4b9c7b11a9228b425c7a73cade1154f2ca061e_CSS.0b204744.chunk.css" data-n-p=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-9e14e9299d96e4a63fc3.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-d7b2fb72fb7257504a38.js" as="script"/><link rel="preload" href="/_next/static/chunks/7af46002.7b37a38a8911fc5fb44b.js" as="script"/><link rel="preload" href="/_next/static/chunks/7658eb265201359a3f9e5f36a5d51cd74c781bde.716fe7386381de1064b0.js" as="script"/><link rel="preload" href="/_next/static/chunks/189f372a1a09b44bc5ee9e8694cd22967121ee9f.c1299753f6cf9d140411.js" as="script"/><link rel="preload" href="/_next/static/chunks/189f372a1a09b44bc5ee9e8694cd22967121ee9f_CSS.8f6f5b95f5e92b2c9bcd.js" as="script"/><link rel="preload" href="/_next/static/chunks/712a84a73acf62bf26290958298b2566586e7dd8_CSS.bca366718f045dbe8189.js" as="script"/><link rel="preload" href="/_next/static/chunks/93b2fd6e127d30331b61cfd2f04634ca05024a66_CSS.19830e50427f38e47434.js" as="script"/><link rel="preload" href="/_next/static/chunks/608d37238a334f4b11fe8d600201fe11b7a5b804.cbf6dda1e316f22fd86b.js" as="script"/><link rel="preload" href="/_next/static/chunks/d111f78934af154ae2b78def2cd48076645f6685.b41fcd8fbee89b9b32b6.js" as="script"/><link rel="preload" href="/_next/static/chunks/e70a2e0268e458e8b9abc18785a5727107407f8e.3f5af21948b0ca66102f.js" as="script"/><link rel="preload" href="/_next/static/chunks/styles.97cfe1edb1cdc49560a5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-307ac3bfcacd4d7be388.js" as="script"/><link rel="preload" href="/_next/static/chunks/8a4b9c7b11a9228b425c7a73cade1154f2ca061e.4a1b4be1a94f0b02499c.js" as="script"/><link rel="preload" href="/_next/static/chunks/8a4b9c7b11a9228b425c7a73cade1154f2ca061e_CSS.4d62413f4da81be1e932.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bid%5D-c6ffa8c08f20ac6ea580.js" as="script"/></head><body><div id="__next"><div><section class="ant-layout"><header class="ant-layout-header ki-header"><div class="ant-row ant-row-center ant-row-middle" style="height:100%"><div class="title-panel"><a class="header-title" href="/">· KIYAK ·</a></div></div></header><main class="ant-layout-content" style="margin-top:50px;padding-left:2px;padding-right:2px;padding-top:2px"><div style="overflow:hidden"><div id="posts-panel"><div class="ant-row ant-row-center"><div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-18 ant-col-lg-13"><div id="posts-content"><h1>Git操作实践</h1>
<h2>速览</h2>
<h3>仓库</h3>
<pre><code class="language-shell"># 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
$ git clone [url]
</code></pre>
<h3>配置</h3>
<pre><code class="language-shell"># 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name "[name]"
$ git config [--global] user.email "[email address]"
</code></pre>
<h3>增加/删除文件</h3>
<pre><code class="language-shell"># 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 添加每个变化前，都会要求确认
# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
</code></pre>
<h3>代码提交</h3>
<pre><code class="language-shell"># 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
</code></pre>
<h3>分支</h3>
<pre><code class="language-shell"># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
</code></pre>
<h3>标签</h3>
<pre><code class="language-shell"># 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 删除本地tag
$ git tag -d [tag]

# 删除远程tag
$ git push origin :refs/tags/[tagName]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
</code></pre>
<h3>查看信息</h3>
<pre><code class="language-shell"># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat "@{0 day ago}"

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
</code></pre>
<h3>远程同步</h3>
<pre><code class="language-shell"># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
</code></pre>
<h3>撤销</h3>
<pre><code class="language-shell"># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
</code></pre>
<h3>其他</h3>
<pre><code class="language-shell"># 生成一个可供发布的压缩包
$ git archive
</code></pre>
<h2>设置Git用户名</h2>
<p>在 Git 中设置自己的用户名是非常必要的一个步骤，因为在提交代码的时候，会记录下提交者的信息，这样就可以很清晰的看到某时某刻是谁推送了代码。</p>
<p><strong>为一个仓库设置 Git 用户名</strong></p>
<ol>
<li>
<p>打开 Git Bash。</p>
</li>
<li>
<p>将当前工作目录更改为您想要在其中配置与 Git 提交关联的名称的本地仓库。</p>
</li>
<li>
<p>设置 Git 用户名以及联系方式：</p>
<pre><code class="language-shell">$ git config user.name "Mona Lisa"
$ git config user.email "email@example.com"
</code></pre>
</li>
<li>
<p>确认您正确设置了 Git 用户名以及联系方式：</p>
<pre><code class="language-shell">$ git config user.name
> Mona Lisa
$ git config user.email
> email@example.com
</code></pre>
</li>
</ol>
<p><strong>为计算机上的每个仓库设置 Git 用户名</strong></p>
<ol>
<li>
<p>打开 Git Bash。</p>
</li>
<li>
<p>设置 Git 用户名：</p>
<pre><code class="language-shell">$ git config --global user.name "Mona Lisa"
$ git config --global user.email "email@example.com"
</code></pre>
</li>
<li>
<p>确认您正确设置了 Git 用户名：</p>
<pre><code class="language-shell">$ git config --global user.name
>Mona Lisa
$ git config --global user.email
> email@example.com
</code></pre>
</li>
</ol>
<h2>获取代码 (Fetch、Pull)</h2>
<p>如果我们有一个远程 Git 分支，例如 Github 上的一个 master 分支，那么远程分支可能有本地分支没有的提交！也许是另一个分支合并了，也许是你的同事推送了一个 BUG 的修复，等等。</p>
<p>如果想要同步这些最新的提交，可以使用两种方式，一种是 <code>git fetch</code>，另一种是 <code>git pull</code>。</p>
<p><code>git fetch</code> 会将远程数据下载至本地，不过也仅仅是下载至本地而已。<br>
<code>git pull</code> 会将远程数据下载至本地，除此之外，它还将下载的数据与本地代码合并。</p>
<p><img src="https://resource.1024kb.top/image/code-sample/git-pull.gif?v=1" alt="git-merge-dev.gif"></p>
<p>通常的，开发人员会使用 <code>git pull</code> 来获取远程 Git 仓库上的最新提交，以达到更新本地代码的目的。其实，<code>git pull</code> 命令行就相当于 <code>git fetch</code> + <code>git merge origin/master</code>。一般来说，更新代码，使用 <code>git pull</code> 就好了。</p>
<h2>合并代码 (Merge)</h2>
<p>合并代码分为两种方式：Fast-forward (--ff)、No-fast-foward (--no-ff)。在多分支的开发环境下，合并代码 (git merge) 也是较为常用的一个命令。</p>
<p><strong>Fast-forward (--ff)</strong> </p>
<p>假设 master 主干要合并 dev 分支上的更改，而 master 相对于 dev 来说没有任何变动，那么 git 会使用 Fast-forward 方式进行一次快速合并。该方式是 git 的“懒”操作，这样不需要 master 主干生成任何提交记录，仅需复用 dev 分支的提交记录即可。</p>
<pre><code class="language-shell">$ git merge dev
Updating 7173edd..7d959a2
Fast-forward
 README.md | 1 +
 1 file changed, 1 insertion(+)
$ git push
</code></pre>
<p><img src="https://resource.1024kb.top/image/code-sample/git-merge-dev.gif?v=2" alt="git-merge-dev.gif"></p>
<p><strong>No-fast-foward (--no-ff)</strong> </p>
<p>假设 master 、dev 两个分支的开发是并行开展的，该情况下进行代码的合并，git 就会主动提示开发人员进行必要的 <strong>commit</strong> 操作，此时的 <code>git merge dev</code> 操作就相当于 <code>git merge --no-ff dev</code>。该情况下的提交记录会与上边的 <strong>Fast-forward (--ff)</strong> 有差异， 因为合并之后，会在 master 与 dev 顶端生成一个新的提交记录。</p>
<pre><code class="language-sh">$ git merge dev
</code></pre>
<pre><code class="language-sh">Merge branch 'dev'
# Please enter a commit message to explain why this merge is necessary,
# especially if it merges an updated upstream into a topic branch.
#
# Lines starting with '#' will be ignored, and an empty message aborts
# the commit.

</code></pre>
<p><img src="https://resource.1024kb.top/image/code-sample/git-merge-no-ff-dev.gif?v=2" alt="git-merge-no-ff-dev.gif"></p>
<h2>合并冲突 (Merge Conflicts)</h2>
<p>合并代码发生冲突是很常见的场景，例如，在某两个分支中，对相同文件的相同位置做了不同的修改，该情况下合并代码，git 是无法自主决定代码的合并的，因为无法确定哪个分支的更改才是最有效的。</p>
<p>假设有A、B程序员以及一个 README.md 文件<br>
A 程序员：编辑 master 主干 README.md 里的第一行文字，更改为：Hey！<br>
B 程序员：编辑 dev 分支 README.md 里的第一行文字，更改为：Hello！<br>
此时合并代码将发生冲突：</p>
<pre><code class="language-shell">$ git merge dev
Auto-merging README.md
CONFLICT (content): Merge conflict in README.md
Automatic merge failed; fix conflicts and then commit the result.
</code></pre>
<p>该情况下需要人为的解决冲突，首先编辑 README.md 文件：</p>
<pre><code class="language-shell">vi README.md
</code></pre>
<p>可以发现 README.md 的内容会有所更改，因为 git 自动填充了两个分支的不同之处，以方便开发人员进行比较，如下所示：</p>
<pre><code class="language-shell">&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C; HEAD
Hey！
=======
Hello！
>>>>>>> dev
</code></pre>
<p>此时只需决定需要保留的内容即可，如保留 <code>Hey！</code>而非 <code>Hello！</code>：</p>
<pre><code class="language-shell">Hey！
</code></pre>
<p>最后重新提交代码即可，本次合并的冲突就解决啦。</p>
<p><img src="https://resource.1024kb.top/image/code-sample/git-merge-conflicts.gif?v=3" alt="git-merge-comflicts.gif"></p>
<h2>变基 (Rebase)</h2>
<p>在之前的操作中可以了解到，<code>git merge</code> 可将更改从一个分支应用于另一个分支。而 git 还有一种类似的操作 <code>git rebase</code>，也可实现将更改从一个分支添加到另一个分支。</p>
<p><img src="https://resource.1024kb.top/image/code-sample/git-rebase.gif?v=3" alt="git-rebase.gif"></p>
<p>如上图所示， <code>git rebase</code> 不同于 <code>git merge</code> 之处，在于 rebase 会重写提交树的结构，以使 master 分支成为当前分支的一部分。</p>
<p>个人理解：使用 rebase ，可以使得当前开发的分支是基于 master 或者其他重要分支进行延伸，而如果当前分支的代码要被 master 或其它分支合并时，可以顺利的完成一次 (Fast-forward) 合并！</p>
<h2>恢复 (Reset、Revert)</h2>
<p>如果在开发过程中对代码做了不理想的更改，比如存在 BUG、功能调整等，那么在推送代码之前，我们还是可以对这些文件内容或者状态进行回滚、恢复、重新编辑等。</p>
<p><strong>Soft reset</strong></p>
<p>假设在本地的 dev 分支分别提交了 style.css 和 index.js 文件的更改，生成了两条记录 <strong>change background-color</strong>、<strong>fixed index logic</strong>，如下图所示：</p>
<p><img src="https://resource.1024kb.top/image/code-sample/git-reset-test.png" alt="git-reset-test"></p>
<p>查看当前 git 的状态：</p>
<pre><code class="language-shell">$ git status
On branch dev
Your branch is ahead of 'origin/dev' by 2 commits.
  (use "git push" to publish your local commits)
</code></pre>
<p>如果想要撤销这两次提交记录，但是需要保留当前更改的内容，那么可以通过执行 <code>git reset --soft HEAD~2</code> 来实现 (<em>HEAD 指针后退两步</em> )。此时观察 git 状态，会显示 index.js、style.css 都处于 <strong>modified</strong> 状态，等待着新的 <strong>commit</strong> (<em>Changes to be committed</em>)。</p>
<pre><code class="language-shell">$ git status
On branch dev
Your branch is up to date with 'origin/dev'.

Changes to be committed:
  (use "git reset HEAD &#x3C;file>..." to unstage)

        modified:   index.js
        modified:   style.css
</code></pre>
<p>相应的，git 的历史记录也有所改变：</p>
<p><img src="https://resource.1024kb.top/image/code-sample/git-reset-test-2.png" alt="git-reset-test-2"></p>
<p><strong>Mixed reset</strong></p>
<p>与 <code>reset --soft</code> 效果一致，唯一不同的是 <code>reset --mixed</code> 会将本地暂存区的缓存删掉。</p>
<pre><code class="language-shell">$ git reset --mixed HEAD~2
Unstaged changes after reset:
M       index.js
M       style.css
</code></pre>
<p>所以如果要重新 <code>commit</code> 文件，需要先对文件进行 <code>git add</code> 操作。</p>
<p><strong>Hard reset</strong></p>
<p><code>reset --hard</code> 命令相对更加的严格，使用 <strong>hard</strong> 不仅会删除本地暂存区的缓存，还会将实际编辑的文件也一并恢复原样。</p>
<pre><code class="language-shell">$ git reset --hard HEAD~2
HEAD is now at 431f5f6 fixed something
</code></pre>
<pre><code class="language-shell">$ git status
On branch dev
Your branch is up to date with 'origin/dev'.

nothing to commit, working tree clean
</code></pre>
<p>观察文件可以看到，文件恢复成了更改前的模样，就好像什么都没发生过。</p>
<p><img src="https://resource.1024kb.top/image/code-sample/git-reset-test-3.png" alt="git-reset-test-3"></p>
<p><strong>revert</strong></p>
<p>git 提供的另一个命令 <strong>revert</strong> 也可以实现代码的回退。与 <strong>reset</strong> 命令不一样，revert 不会删除暂存区数据、也不会回退 <strong>HEAD</strong> 指针，相反，revert 会要求新增对应的 commit ，来加以说明为什么要对文件进行恢复或者回退操作。</p>
<p>比如需要回滚以上 index.js 、style.css 两个文件的代码并且记录下原因，那么可以使用 <code>git revert HEAD~2..</code> 来实现。</p>
<p>查看 git 的历史记录：</p>
<p><img src="https://resource.1024kb.top/image/code-sample/git-reset-test-4.png" alt="git-reset-test-3"></p>
<pre><code class="language-shell">git revert HEAD #撤销最新提交
git revert HEAD^ #撤销倒数第2次提交
git revert HEAD~2 #撤销倒数第3次提交
git revert HEAD~2.. #撤销最新两次提交
git revert commit-id #撤销指定的 commit-id
</code></pre>
<h1>参考资料</h1>
<ul>
<li>GitHub, 在 Git 中设置用户名, <em>GitHub help</em>. <a href="https://help.github.com/cn/github/using-git/setting-your-username-in-git">📄</a></li>
<li>阮一峰, 常用 Git 命令清单, <em>阮一峰的网络日志</em>, 2015. <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">📄</a></li>
<li>Rob Di Marco, Peter Mortensen, “When do you use Git rebase instead of Git merge?”, <em>Stack Overflow</em>, 2019. <a href="https://stackoverflow.com/a/804156">📄</a></li>
<li>Lydia Hallie, 🌳🚀 CS Visualized: Useful Git Commands, <em>DEV</em>, 2020. <a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1">📄</a></li>
<li>GitHowTo. <a href="https://githowto.com">📄</a></li>
</ul>
</div></div></div><div style="position:fixed;bottom:150px;right:50px"><nav id="posts-nav"><ul style="list-style:none"></ul></nav></div><div class="ant-row ant-row-center" style="margin-bottom:40px;margin-top:40px"><span class="ant-typography"><u>· last updated：<!-- --> ·</u></span></div></div></div><span style="position:fixed;bottom:60px;right:15px;z-index:999;background-color:#555555" class="ant-avatar ant-avatar-lg ant-avatar-circle ant-avatar-icon ant-dropdown-trigger"><span role="img" aria-label="unordered-list" class="anticon anticon-unordered-list"><svg viewBox="64 64 896 896" focusable="false" class="" data-icon="unordered-list" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z"></path></svg></span></span><div style="display:none" class="web-map"><a href="/">主页</a><a href="/notes">笔记</a></div></main><footer class="ant-layout-footer ki-footer"><a href="http://www.beian.miit.gov.cn" target="_blank" style="color:rgba(250, 250, 250, 0.938)">桂ICP备18000815号-2 © 2017 - 2020 - KIYAK-WEB</a></footer></section></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"filename":"programming/[Git]操作实践.md","title":"Git操作实践","excerpt":"","date":"2020-05-28T18:00:00.000Z","updated":"2020-05-28T18:00:00.000Z","preText":"Git","preTextColor":"#FF6666","content":"\u003ch1\u003eGit操作实践\u003c/h1\u003e\n\u003ch2\u003e速览\u003c/h2\u003e\n\u003ch3\u003e仓库\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e配置\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e增加/删除文件\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e代码提交\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e分支\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e标签\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e查看信息\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e远程同步\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e撤销\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e其他\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e# 生成一个可供发布的压缩包\n$ git archive\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e设置Git用户名\u003c/h2\u003e\n\u003cp\u003e在 Git 中设置自己的用户名是非常必要的一个步骤，因为在提交代码的时候，会记录下提交者的信息，这样就可以很清晰的看到某时某刻是谁推送了代码。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e为一个仓库设置 Git 用户名\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e打开 Git Bash。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e将当前工作目录更改为您想要在其中配置与 Git 提交关联的名称的本地仓库。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e设置 Git 用户名以及联系方式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ git config user.name \"Mona Lisa\"\n$ git config user.email \"email@example.com\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e确认您正确设置了 Git 用户名以及联系方式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ git config user.name\n\u003e Mona Lisa\n$ git config user.email\n\u003e email@example.com\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e为计算机上的每个仓库设置 Git 用户名\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e打开 Git Bash。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e设置 Git 用户名：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ git config --global user.name \"Mona Lisa\"\n$ git config --global user.email \"email@example.com\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e确认您正确设置了 Git 用户名：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ git config --global user.name\n\u003eMona Lisa\n$ git config --global user.email\n\u003e email@example.com\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e获取代码 (Fetch、Pull)\u003c/h2\u003e\n\u003cp\u003e如果我们有一个远程 Git 分支，例如 Github 上的一个 master 分支，那么远程分支可能有本地分支没有的提交！也许是另一个分支合并了，也许是你的同事推送了一个 BUG 的修复，等等。\u003c/p\u003e\n\u003cp\u003e如果想要同步这些最新的提交，可以使用两种方式，一种是 \u003ccode\u003egit fetch\u003c/code\u003e，另一种是 \u003ccode\u003egit pull\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egit fetch\u003c/code\u003e 会将远程数据下载至本地，不过也仅仅是下载至本地而已。\u003cbr\u003e\n\u003ccode\u003egit pull\u003c/code\u003e 会将远程数据下载至本地，除此之外，它还将下载的数据与本地代码合并。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://resource.1024kb.top/image/code-sample/git-pull.gif?v=1\" alt=\"git-merge-dev.gif\"\u003e\u003c/p\u003e\n\u003cp\u003e通常的，开发人员会使用 \u003ccode\u003egit pull\u003c/code\u003e 来获取远程 Git 仓库上的最新提交，以达到更新本地代码的目的。其实，\u003ccode\u003egit pull\u003c/code\u003e 命令行就相当于 \u003ccode\u003egit fetch\u003c/code\u003e + \u003ccode\u003egit merge origin/master\u003c/code\u003e。一般来说，更新代码，使用 \u003ccode\u003egit pull\u003c/code\u003e 就好了。\u003c/p\u003e\n\u003ch2\u003e合并代码 (Merge)\u003c/h2\u003e\n\u003cp\u003e合并代码分为两种方式：Fast-forward (--ff)、No-fast-foward (--no-ff)。在多分支的开发环境下，合并代码 (git merge) 也是较为常用的一个命令。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFast-forward (--ff)\u003c/strong\u003e \u003c/p\u003e\n\u003cp\u003e假设 master 主干要合并 dev 分支上的更改，而 master 相对于 dev 来说没有任何变动，那么 git 会使用 Fast-forward 方式进行一次快速合并。该方式是 git 的“懒”操作，这样不需要 master 主干生成任何提交记录，仅需复用 dev 分支的提交记录即可。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ git merge dev\nUpdating 7173edd..7d959a2\nFast-forward\n README.md | 1 +\n 1 file changed, 1 insertion(+)\n$ git push\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://resource.1024kb.top/image/code-sample/git-merge-dev.gif?v=2\" alt=\"git-merge-dev.gif\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNo-fast-foward (--no-ff)\u003c/strong\u003e \u003c/p\u003e\n\u003cp\u003e假设 master 、dev 两个分支的开发是并行开展的，该情况下进行代码的合并，git 就会主动提示开发人员进行必要的 \u003cstrong\u003ecommit\u003c/strong\u003e 操作，此时的 \u003ccode\u003egit merge dev\u003c/code\u003e 操作就相当于 \u003ccode\u003egit merge --no-ff dev\u003c/code\u003e。该情况下的提交记录会与上边的 \u003cstrong\u003eFast-forward (--ff)\u003c/strong\u003e 有差异， 因为合并之后，会在 master 与 dev 顶端生成一个新的提交记录。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003e$ git merge dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003eMerge branch 'dev'\n# Please enter a commit message to explain why this merge is necessary,\n# especially if it merges an updated upstream into a topic branch.\n#\n# Lines starting with '#' will be ignored, and an empty message aborts\n# the commit.\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"https://resource.1024kb.top/image/code-sample/git-merge-no-ff-dev.gif?v=2\" alt=\"git-merge-no-ff-dev.gif\"\u003e\u003c/p\u003e\n\u003ch2\u003e合并冲突 (Merge Conflicts)\u003c/h2\u003e\n\u003cp\u003e合并代码发生冲突是很常见的场景，例如，在某两个分支中，对相同文件的相同位置做了不同的修改，该情况下合并代码，git 是无法自主决定代码的合并的，因为无法确定哪个分支的更改才是最有效的。\u003c/p\u003e\n\u003cp\u003e假设有A、B程序员以及一个 README.md 文件\u003cbr\u003e\nA 程序员：编辑 master 主干 README.md 里的第一行文字，更改为：Hey！\u003cbr\u003e\nB 程序员：编辑 dev 分支 README.md 里的第一行文字，更改为：Hello！\u003cbr\u003e\n此时合并代码将发生冲突：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ git merge dev\nAuto-merging README.md\nCONFLICT (content): Merge conflict in README.md\nAutomatic merge failed; fix conflicts and then commit the result.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e该情况下需要人为的解决冲突，首先编辑 README.md 文件：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003evi README.md\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以发现 README.md 的内容会有所更改，因为 git 自动填充了两个分支的不同之处，以方便开发人员进行比较，如下所示：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e\u0026#x3C;\u0026#x3C;\u0026#x3C;\u0026#x3C;\u0026#x3C;\u0026#x3C;\u0026#x3C; HEAD\nHey！\n=======\nHello！\n\u003e\u003e\u003e\u003e\u003e\u003e\u003e dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e此时只需决定需要保留的内容即可，如保留 \u003ccode\u003eHey！\u003c/code\u003e而非 \u003ccode\u003eHello！\u003c/code\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003eHey！\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e最后重新提交代码即可，本次合并的冲突就解决啦。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://resource.1024kb.top/image/code-sample/git-merge-conflicts.gif?v=3\" alt=\"git-merge-comflicts.gif\"\u003e\u003c/p\u003e\n\u003ch2\u003e变基 (Rebase)\u003c/h2\u003e\n\u003cp\u003e在之前的操作中可以了解到，\u003ccode\u003egit merge\u003c/code\u003e 可将更改从一个分支应用于另一个分支。而 git 还有一种类似的操作 \u003ccode\u003egit rebase\u003c/code\u003e，也可实现将更改从一个分支添加到另一个分支。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://resource.1024kb.top/image/code-sample/git-rebase.gif?v=3\" alt=\"git-rebase.gif\"\u003e\u003c/p\u003e\n\u003cp\u003e如上图所示， \u003ccode\u003egit rebase\u003c/code\u003e 不同于 \u003ccode\u003egit merge\u003c/code\u003e 之处，在于 rebase 会重写提交树的结构，以使 master 分支成为当前分支的一部分。\u003c/p\u003e\n\u003cp\u003e个人理解：使用 rebase ，可以使得当前开发的分支是基于 master 或者其他重要分支进行延伸，而如果当前分支的代码要被 master 或其它分支合并时，可以顺利的完成一次 (Fast-forward) 合并！\u003c/p\u003e\n\u003ch2\u003e恢复 (Reset、Revert)\u003c/h2\u003e\n\u003cp\u003e如果在开发过程中对代码做了不理想的更改，比如存在 BUG、功能调整等，那么在推送代码之前，我们还是可以对这些文件内容或者状态进行回滚、恢复、重新编辑等。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSoft reset\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e假设在本地的 dev 分支分别提交了 style.css 和 index.js 文件的更改，生成了两条记录 \u003cstrong\u003echange background-color\u003c/strong\u003e、\u003cstrong\u003efixed index logic\u003c/strong\u003e，如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://resource.1024kb.top/image/code-sample/git-reset-test.png\" alt=\"git-reset-test\"\u003e\u003c/p\u003e\n\u003cp\u003e查看当前 git 的状态：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ git status\nOn branch dev\nYour branch is ahead of 'origin/dev' by 2 commits.\n  (use \"git push\" to publish your local commits)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果想要撤销这两次提交记录，但是需要保留当前更改的内容，那么可以通过执行 \u003ccode\u003egit reset --soft HEAD~2\u003c/code\u003e 来实现 (\u003cem\u003eHEAD 指针后退两步\u003c/em\u003e )。此时观察 git 状态，会显示 index.js、style.css 都处于 \u003cstrong\u003emodified\u003c/strong\u003e 状态，等待着新的 \u003cstrong\u003ecommit\u003c/strong\u003e (\u003cem\u003eChanges to be committed\u003c/em\u003e)。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ git status\nOn branch dev\nYour branch is up to date with 'origin/dev'.\n\nChanges to be committed:\n  (use \"git reset HEAD \u0026#x3C;file\u003e...\" to unstage)\n\n        modified:   index.js\n        modified:   style.css\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e相应的，git 的历史记录也有所改变：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://resource.1024kb.top/image/code-sample/git-reset-test-2.png\" alt=\"git-reset-test-2\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eMixed reset\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e与 \u003ccode\u003ereset --soft\u003c/code\u003e 效果一致，唯一不同的是 \u003ccode\u003ereset --mixed\u003c/code\u003e 会将本地暂存区的缓存删掉。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ git reset --mixed HEAD~2\nUnstaged changes after reset:\nM       index.js\nM       style.css\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所以如果要重新 \u003ccode\u003ecommit\u003c/code\u003e 文件，需要先对文件进行 \u003ccode\u003egit add\u003c/code\u003e 操作。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHard reset\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereset --hard\u003c/code\u003e 命令相对更加的严格，使用 \u003cstrong\u003ehard\u003c/strong\u003e 不仅会删除本地暂存区的缓存，还会将实际编辑的文件也一并恢复原样。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ git reset --hard HEAD~2\nHEAD is now at 431f5f6 fixed something\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ git status\nOn branch dev\nYour branch is up to date with 'origin/dev'.\n\nnothing to commit, working tree clean\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e观察文件可以看到，文件恢复成了更改前的模样，就好像什么都没发生过。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://resource.1024kb.top/image/code-sample/git-reset-test-3.png\" alt=\"git-reset-test-3\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003erevert\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003egit 提供的另一个命令 \u003cstrong\u003erevert\u003c/strong\u003e 也可以实现代码的回退。与 \u003cstrong\u003ereset\u003c/strong\u003e 命令不一样，revert 不会删除暂存区数据、也不会回退 \u003cstrong\u003eHEAD\u003c/strong\u003e 指针，相反，revert 会要求新增对应的 commit ，来加以说明为什么要对文件进行恢复或者回退操作。\u003c/p\u003e\n\u003cp\u003e比如需要回滚以上 index.js 、style.css 两个文件的代码并且记录下原因，那么可以使用 \u003ccode\u003egit revert HEAD~2..\u003c/code\u003e 来实现。\u003c/p\u003e\n\u003cp\u003e查看 git 的历史记录：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://resource.1024kb.top/image/code-sample/git-reset-test-4.png\" alt=\"git-reset-test-3\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003egit revert HEAD #撤销最新提交\ngit revert HEAD^ #撤销倒数第2次提交\ngit revert HEAD~2 #撤销倒数第3次提交\ngit revert HEAD~2.. #撤销最新两次提交\ngit revert commit-id #撤销指定的 commit-id\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e参考资料\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eGitHub, 在 Git 中设置用户名, \u003cem\u003eGitHub help\u003c/em\u003e. \u003ca href=\"https://help.github.com/cn/github/using-git/setting-your-username-in-git\"\u003e📄\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e阮一峰, 常用 Git 命令清单, \u003cem\u003e阮一峰的网络日志\u003c/em\u003e, 2015. \u003ca href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\"\u003e📄\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eRob Di Marco, Peter Mortensen, “When do you use Git rebase instead of Git merge?”, \u003cem\u003eStack Overflow\u003c/em\u003e, 2019. \u003ca href=\"https://stackoverflow.com/a/804156\"\u003e📄\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eLydia Hallie, 🌳🚀 CS Visualized: Useful Git Commands, \u003cem\u003eDEV\u003c/em\u003e, 2020. \u003ca href=\"https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1\"\u003e📄\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eGitHowTo. \u003ca href=\"https://githowto.com\"\u003e📄\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"git-practice"},"buildId":"pGGBVmnLCT4XKOq0_CdKw","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"Git操作实践 - kiyak"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-577caaa53936537aa4bf.js"></script><script src="/_next/static/chunks/main-9e14e9299d96e4a63fc3.js" async=""></script><script src="/_next/static/chunks/webpack-d7b2fb72fb7257504a38.js" async=""></script><script src="/_next/static/chunks/7af46002.7b37a38a8911fc5fb44b.js" async=""></script><script src="/_next/static/chunks/7658eb265201359a3f9e5f36a5d51cd74c781bde.716fe7386381de1064b0.js" async=""></script><script src="/_next/static/chunks/189f372a1a09b44bc5ee9e8694cd22967121ee9f.c1299753f6cf9d140411.js" async=""></script><script src="/_next/static/chunks/189f372a1a09b44bc5ee9e8694cd22967121ee9f_CSS.8f6f5b95f5e92b2c9bcd.js" async=""></script><script src="/_next/static/chunks/712a84a73acf62bf26290958298b2566586e7dd8_CSS.bca366718f045dbe8189.js" async=""></script><script src="/_next/static/chunks/93b2fd6e127d30331b61cfd2f04634ca05024a66_CSS.19830e50427f38e47434.js" async=""></script><script src="/_next/static/chunks/608d37238a334f4b11fe8d600201fe11b7a5b804.cbf6dda1e316f22fd86b.js" async=""></script><script src="/_next/static/chunks/d111f78934af154ae2b78def2cd48076645f6685.b41fcd8fbee89b9b32b6.js" async=""></script><script src="/_next/static/chunks/e70a2e0268e458e8b9abc18785a5727107407f8e.3f5af21948b0ca66102f.js" async=""></script><script src="/_next/static/chunks/styles.97cfe1edb1cdc49560a5.js" async=""></script><script src="/_next/static/chunks/pages/_app-307ac3bfcacd4d7be388.js" async=""></script><script src="/_next/static/chunks/8a4b9c7b11a9228b425c7a73cade1154f2ca061e.4a1b4be1a94f0b02499c.js" async=""></script><script src="/_next/static/chunks/8a4b9c7b11a9228b425c7a73cade1154f2ca061e_CSS.4d62413f4da81be1e932.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-c6ffa8c08f20ac6ea580.js" async=""></script><script src="/_next/static/pGGBVmnLCT4XKOq0_CdKw/_buildManifest.js" async=""></script><script src="/_next/static/pGGBVmnLCT4XKOq0_CdKw/_ssgManifest.js" async=""></script></body></html>