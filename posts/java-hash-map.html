<!DOCTYPE html><html lang="zh-Hans"><head><meta charSet="utf-8"/><meta name="viewport" content="initial-scale=1.0, width=device-width"/><meta name="baidu-site-verification" content="cbUbgjjdru"/><meta name="generator" content="Next.js"/><link href="https://fonts.googleapis.com/css?family=Chelsea+Market:400" rel="stylesheet"/><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500&amp;display=swap" rel="stylesheet"/><link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@300;400;500&amp;display=swap" rel="stylesheet"/><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/><script src="https://cdn.bootcdn.net/ajax/libs/react/16.13.1/umd/react.production.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/react-dom/16.13.1/umd/react-dom.production.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.0.3/highlight.min.js"></script><script src="/_.v1.js"></script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>HashMapåŸç†ç®€æ - kiyak</title><link rel="preload" href="/_next/static/css/7af46002.794d2e46.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7af46002.794d2e46.chunk.css" data-n-g=""/><link rel="preload" href="/_next/static/css/189f372a1a09b44bc5ee9e8694cd22967121ee9f_CSS.48deeafe.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/189f372a1a09b44bc5ee9e8694cd22967121ee9f_CSS.48deeafe.chunk.css" data-n-g=""/><link rel="preload" href="/_next/static/css/712a84a73acf62bf26290958298b2566586e7dd8_CSS.77aeb35e.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/712a84a73acf62bf26290958298b2566586e7dd8_CSS.77aeb35e.chunk.css" data-n-g=""/><link rel="preload" href="/_next/static/css/93b2fd6e127d30331b61cfd2f04634ca05024a66_CSS.c9bcc403.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/93b2fd6e127d30331b61cfd2f04634ca05024a66_CSS.c9bcc403.chunk.css" data-n-g=""/><link rel="preload" href="/_next/static/css/styles.a71acdf5.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/styles.a71acdf5.chunk.css" data-n-g=""/><link rel="preload" href="/_next/static/css/8a4b9c7b11a9228b425c7a73cade1154f2ca061e_CSS.0b204744.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8a4b9c7b11a9228b425c7a73cade1154f2ca061e_CSS.0b204744.chunk.css" data-n-p=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-9e14e9299d96e4a63fc3.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-d7b2fb72fb7257504a38.js" as="script"/><link rel="preload" href="/_next/static/chunks/7af46002.7b37a38a8911fc5fb44b.js" as="script"/><link rel="preload" href="/_next/static/chunks/7658eb265201359a3f9e5f36a5d51cd74c781bde.716fe7386381de1064b0.js" as="script"/><link rel="preload" href="/_next/static/chunks/189f372a1a09b44bc5ee9e8694cd22967121ee9f.c1299753f6cf9d140411.js" as="script"/><link rel="preload" href="/_next/static/chunks/189f372a1a09b44bc5ee9e8694cd22967121ee9f_CSS.8f6f5b95f5e92b2c9bcd.js" as="script"/><link rel="preload" href="/_next/static/chunks/712a84a73acf62bf26290958298b2566586e7dd8_CSS.bca366718f045dbe8189.js" as="script"/><link rel="preload" href="/_next/static/chunks/93b2fd6e127d30331b61cfd2f04634ca05024a66_CSS.19830e50427f38e47434.js" as="script"/><link rel="preload" href="/_next/static/chunks/608d37238a334f4b11fe8d600201fe11b7a5b804.cbf6dda1e316f22fd86b.js" as="script"/><link rel="preload" href="/_next/static/chunks/d111f78934af154ae2b78def2cd48076645f6685.b41fcd8fbee89b9b32b6.js" as="script"/><link rel="preload" href="/_next/static/chunks/e70a2e0268e458e8b9abc18785a5727107407f8e.3f5af21948b0ca66102f.js" as="script"/><link rel="preload" href="/_next/static/chunks/styles.97cfe1edb1cdc49560a5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-307ac3bfcacd4d7be388.js" as="script"/><link rel="preload" href="/_next/static/chunks/8a4b9c7b11a9228b425c7a73cade1154f2ca061e.4a1b4be1a94f0b02499c.js" as="script"/><link rel="preload" href="/_next/static/chunks/8a4b9c7b11a9228b425c7a73cade1154f2ca061e_CSS.4d62413f4da81be1e932.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bid%5D-c6ffa8c08f20ac6ea580.js" as="script"/></head><body><div id="__next"><div><section class="ant-layout"><header class="ant-layout-header ki-header"><div class="ant-row ant-row-center ant-row-middle" style="height:100%"><div class="title-panel"><a class="header-title" href="/">Â· KIYAK Â·</a></div></div></header><main class="ant-layout-content" style="margin-top:50px;padding-left:2px;padding-right:2px;padding-top:2px"><div style="overflow:hidden"><div id="posts-panel"><div class="ant-row ant-row-center"><div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-18 ant-col-lg-13"><div id="posts-content"><h1>HashMapåŸç†ç®€æ</h1>
<h2>æ¦‚è¿°</h2>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933">æ•£åˆ—è¡¨</a>ï¼ˆHash tableï¼Œä¹Ÿå«å“ˆå¸Œè¡¨ï¼‰ï¼Œæ˜¯æ ¹æ®å…³é”®ç å€¼(Key value)è€Œç›´æ¥è¿›è¡Œè®¿é—®çš„<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450">æ•°æ®ç»“æ„</a>ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒé€šè¿‡æŠŠå…³é”®ç å€¼æ˜ å°„åˆ°è¡¨ä¸­ä¸€ä¸ªä½ç½®æ¥è®¿é—®è®°å½•ï¼Œä»¥åŠ å¿«æŸ¥æ‰¾çš„é€Ÿåº¦ã€‚è¿™ä¸ªæ˜ å°„å‡½æ•°å«åš<a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288">æ•£åˆ—å‡½æ•°</a>ï¼Œå­˜æ”¾è®°å½•çš„<a href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097">æ•°ç»„</a>å«åš<a href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933">æ•£åˆ—è¡¨</a>ã€‚</p>
</blockquote>
<p><strong>HashMap</strong> æ˜¯ Java é¡¹ç›®å¼€å‘è€…ä½¿ç”¨é¢‘ç‡æœ€é«˜çš„å·¥å…·ç±»ä¹‹ä¸€ï¼Œå®ƒå†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œç”¨äºæ˜ å°„(é”®å€¼å¯¹)å¤„ç†çš„æ•°æ®ç±»å‹ï¼Œå¯ä»¥è¯´ HashMap åœ¨é¡¹ç›®ä»£ç ä¸­å‡ ä¹éšå¤„å¯è§ã€‚</p>
<h2>è¦ç‚¹</h2>
<p>å®˜æ–¹<a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">æ–‡æ¡£</a>é‡Œå·²ç»å¯¹ HashMap è¿›è¡Œäº†æè¿°ï¼Œå¤§è‡´æœ‰ä¸‹åˆ— 5 ä¸ªè¦ç‚¹ï¼š</p>
<ol>
<li>å…è®¸ <code>null</code> å€¼ä¸ <code>null</code> key</li>
<li>æ— æ³•ä¿è¯é¡ºåº</li>
<li>å½±å“æ€§èƒ½çš„ä¸¤ä¸ªå› ç´ ï¼š<em>capacity</em> å’Œ <em>load factor</em></li>
<li>ä¸ä¿è¯çº¿ç¨‹åŒæ­¥</li>
<li>å…·å¤‡ <em>fail-fast</em> ä¿æŠ¤æœºåˆ¶</li>
</ol>
<p><em>capacity</em> æŒ‡çš„æ˜¯å“ˆå¸Œè¡¨çš„å®¹é‡ï¼Œ <em>load factor</em> æŒ‡çš„æ˜¯å“ˆå¸Œè¡¨çš„è´Ÿè½½å› å­ï¼Œå…³äºè¿™ä¸¤ä¸ªå˜é‡çš„å…³ç³»ï¼Œå®˜æ–¹çš„æè¿°æ˜¯ï¼š</p>
<blockquote>
<p>The <em>load factor</em> is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is <strong><em>rehashed</em></strong> (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.</p>
</blockquote>
<blockquote>
<p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the <code>HashMap</code> class, including <code>get</code> and <code>put</code>). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity,</p>
</blockquote>
<p>ç®€è€Œè¨€ä¹‹ï¼š</p>
<ul>
<li>åªè¦æ»¡è¶³æ¡ä»¶ <code>æ€»æ•°æ®é‡ > load factor * current capacity</code>ï¼ŒHashMap å†…éƒ¨çš„å“ˆå¸Œè¡¨å°±ä¼šè¢«é‡æ„ (ç®€ç§° rehash)ï¼Œå“ˆå¸Œè¡¨å®¹é‡æ‰©å¤§è‡³åŸæ¥çš„ 2 å€ã€‚</li>
<li>ä¸ºé¿å…å“ˆå¸Œè¡¨ rehash å¸¦æ¥çš„æ€§èƒ½æŸè€—ï¼Œå»ºè®®è€ƒè™‘åˆå§‹å®¹é‡å¤§å° <em>initial capacity</em>ã€‚</li>
<li><em>load factor</em> é»˜è®¤å€¼æ˜¯ 0.75ï¼Œè¯¥å€¼çš„å®šä¹‰æƒè¡¡äº†æ—¶é—´ä¸ç©ºé—´çš„æˆæœ¬ï¼Œè®¾ç½®å¤ªé«˜æˆ–è€…å¤ªä½éƒ½ä¼šå¯¼è‡´æ€§èƒ½å¤±è¡¡ã€‚</li>
</ul>
<h2>åˆå§‹åŒ–</h2>
<p>HashMap æä¾›å››ä¸ªæ„é€ å‡½æ•°ã€‚</p>
<pre><code class="language-java">public HashMap() // é»˜è®¤
public HashMap(int initialCapacity) // æŒ‡å®šåˆå§‹åŒ–å®¹é‡
public HashMap(int initialCapacity, float loadFactor) // æŒ‡å®šåˆå§‹åŒ–å®¹é‡ã€è´Ÿè½½å› å­
public HashMap(Map&#x3C;? extends K, ? extends V> m) // åˆå§‹åŒ–å¹¶ä¸”å¤åˆ¶å¦å¤–ä¸€ä¸ª Map
</code></pre>
<p>å¦‚æœæœªæŒ‡å®š <code>initialCapacity</code>ï¼Œé‚£ä¹ˆ (åˆå§‹) å“ˆå¸Œè¡¨å®¹é‡é»˜è®¤æ˜¯ <strong>16</strong>ï¼Œå¦‚æœæœªæŒ‡å®š <code>loadFactor</code>ï¼Œé‚£ä¹ˆè´Ÿè½½å› å­é»˜è®¤æ˜¯ <strong>0.75</strong>ã€‚æ­£å¸¸æƒ…å†µä¸‹ï¼Œå¼€å‘äººå‘˜æ— éœ€æ”¹åŠ¨ <code>loadFactor</code> æ•°å€¼ã€‚</p>
<pre><code class="language-java">static final int DEFAULT_INITIAL_CAPACITY = 1 &#x3C;&#x3C; 4; // aka 16
static final float DEFAULT_LOAD_FACTOR = 0.75f;
</code></pre>
<p>æ ¹æ® HashMap çš„æ–‡æ¡£æ‰€è¿°ï¼Œå¯é€šè¿‡é¢„ä¼°éœ€è¦å­˜å‚¨çš„æ•°æ®é‡ï¼Œæ¥é¿å…ä¸å¿…è¦çš„ rehashã€‚<a href="https://github.com/alibaba/p3c">é˜¿é‡Œå·´å·´Javaå¼€å‘æ‰‹å†Œ</a>ä¹Ÿé’ˆå¯¹è¿™ç§æƒ…å†µè¿›è¡Œäº†æè¿°ï¼š</p>
<blockquote>
<p>è¯´æ˜ï¼šHashMap ä½¿ç”¨ HashMap(int initialCapacity) åˆå§‹åŒ–ï¼Œå¦‚æœæš‚æ—¶æ— æ³•ç¡®å®šé›†åˆå¤§å°ï¼Œé‚£ä¹ˆæŒ‡å®šé»˜è®¤å€¼ï¼ˆ16ï¼‰å³å¯ã€‚<br>
æ­£ä¾‹ï¼šinitialCapacity = (éœ€è¦å­˜å‚¨çš„å…ƒç´ ä¸ªæ•° / è´Ÿè½½å› å­) + 1ã€‚æ³¨æ„è´Ÿè½½å› å­ï¼ˆå³ loader factorï¼‰é»˜è®¤ä¸º 0.75ï¼Œå¦‚æœæš‚æ—¶æ— æ³•ç¡®å®šåˆå§‹å€¼å¤§å°ï¼Œè¯·è®¾ç½®ä¸º 16ï¼ˆå³é»˜è®¤å€¼ï¼‰ã€‚<br>
åä¾‹ï¼šHashMap éœ€è¦æ”¾ç½® 1024 ä¸ªå…ƒç´ ï¼Œç”±äºæ²¡æœ‰è®¾ç½®å®¹é‡åˆå§‹å¤§å°ï¼Œéšç€å…ƒç´ ä¸æ–­å¢åŠ ï¼Œå®¹é‡ 7 æ¬¡è¢«è¿«æ‰©å¤§ï¼Œresize éœ€è¦é‡å»º hash è¡¨ã€‚å½“æ”¾ç½®çš„é›†åˆå…ƒç´ ä¸ªæ•°è¾¾åƒä¸‡çº§åˆ«æ—¶ï¼Œä¸æ–­æ‰©å®¹ä¼šä¸¥é‡å½±å“æ€§èƒ½ã€‚</p>
</blockquote>
<p>ç±»ä¼¼çš„ï¼ŒGoogle å‡ºå“çš„ Guava åº“ä¹Ÿé’ˆå¯¹ HashMap çš„åˆå§‹åŒ–è¿›è¡Œäº†å°è£…ï¼š</p>
<pre><code class="language-java">public static &#x3C;K, V> HashMap&#x3C;K, V> newHashMapWithExpectedSize(int expectedSize) {
    return new HashMap(capacity(expectedSize));
}

static int capacity(int expectedSize) {
    if (expectedSize &#x3C; 3) {
        CollectPreconditions.checkNonnegative(expectedSize, "expectedSize");
        return expectedSize + 1;
    } else {
        return expectedSize &#x3C; 1073741824 ? (int)((float)expectedSize / 0.75F + 1.0F) : 2147483647;
    }
}
</code></pre>
<p>æ— ä¸€ä¾‹å¤–ï¼Œå®ƒä»¬éƒ½ä½¿ç”¨ <code>((float) expectedSize / loadFactor) + 1.0F</code> ä½œä¸º HashMap çš„å…¥å‚ã€‚å› æ­¤åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œå¦‚æœçŸ¥é“éœ€è¦å­˜å‚¨çš„æ•°æ®é‡è¾ƒå¤§ï¼Œå¯ä»¥é‡‡ç”¨è¿™äº›æ–¹å¼è¿›è¡Œåˆå§‹åŒ–ï¼Œæé«˜ç³»ç»Ÿè¿è¡Œçš„æ•ˆç‡ã€‚</p>
<h2>å­˜æ•°æ®(put)</h2>
<p>åœ¨æ‰§è¡Œä¸€è¡Œ <code>map.put("one", "")</code>ä»£ç å¤§æ¦‚å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ</p>
<hr>
<ol>
<li>æ ¹æ®å­—ç¬¦ä¸² <em>one</em> çš„ <em>hashCode()</em> åšä¸€æ¬¡ <em>hash</em> è®¡ç®—</li>
<li>åˆ¤æ–­å“ˆå¸Œè¡¨æ˜¯å¦åˆå§‹åŒ–ã€‚å¦ï¼Œåˆ™è¿›è¡Œåˆå§‹åŒ– <code>resize</code></li>
<li>æ ¹æ® <em>hash</em> è®¡ç®— <em>one</em> åœ¨å“ˆå¸Œè¡¨çš„å®é™…ä½ç½® <em>index</em></li>
<li>åˆ¤æ–­æ‰€å¤„ä½ç½®æ˜¯å¦æœ‰æ•°æ® (å“ˆå¸Œç¢°æ’)<ul>
<li>æœ‰ä¸”ç­‰äº <em>one</em> ï¼ŒæŠŠæ—§æ•°æ®è¦†ç›–æ‰</li>
<li>æœ‰ä¸”ä¸ç­‰äº <em>one</em><ul>
<li>åœ¨å½“å‰ä½ç½®ä»¥é“¾è¡¨æ–¹å¼è¿½åŠ ã€‚å¦‚æœé“¾è¡¨é•¿åº¦å¤§äºç­‰äº 7ï¼Œé“¾è¡¨é‡æ„ä¸ºçº¢é»‘æ ‘<br>
å¦‚æœè¿½åŠ è¿‡ç¨‹å‘ç°ç›¸åŒæ•°æ®  <em>one</em>ï¼Œè¦†ç›–æ—§æ•°æ®</li>
</ul></li>
<li>æ— ï¼Œç›´æ¥å­˜å…¥å“ˆå¸Œè¡¨</li>
</ul></li>
<li>å¦‚æœå½“å‰æ»¡è¶³ <code>æ€»æ•°æ®é‡ > load factor * current capacity</code>ï¼Œåˆ™æ•°æ®ç»“æ„é‡æ„ <code>resize</code></li>
</ol>
<hr>
<p>ä»¥ä¸Šæµç¨‹å¯ç›´æ¥è¿›å…¥ <strong>java.util.HashMap#put</strong> æ–¹æ³•ä¸€æ¢ç©¶ç«Ÿã€‚</p>
<h2>å“ˆå¸Œè¡¨çš„å®¹é‡(2^n)</h2>
<p>æ— è®ºæ˜¯å“ˆå¸Œè¡¨é»˜è®¤å¤§å°ã€æŒ‡å®šåˆå§‹å¤§å°ã€æ‰©å®¹å¤§å°ï¼Œç»“æœéƒ½å°†æ˜¯ <strong>2çš„å¹‚</strong>ï¼ˆ2çš„næ¬¡æ–¹ï¼‰ã€‚</p>
<p>å¦‚æœæŒ‡å®š <code>initialCapacity</code>ï¼Œé‚£ä¹ˆ <code>initialCapacity</code> å°±ä¼šè¢« <strong>java.util.HashMap#tableSizeFor</strong> æ–¹æ³•å¤„ç†ã€‚</p>
<pre><code class="language-java">public HashMap(int initialCapacity)
                          |
                          |_______
                                  |
static final int tableSizeFor(int cap)
</code></pre>
<pre><code class="language-java">/**
* Returns a power of two size for the given target capacity.
*/
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n &#x3C; 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre>
<p>å‡è®¾æŒ‡å®š <code>initialCapacity = 7</code>ï¼Œé‚£ä¹ˆæ ¹æ®ä»£ç é€»è¾‘å¯æ¨æ¼”å‡ºä»¥ä¸‹å†…å®¹ï¼š</p>
<pre><code class="language-markdown">cap = 7
n = cap - 1 = 6 = 0 1 1 0
n |= n >>> 1;    0 1 1 0 | 0 0 1 1 = 0 1 1 1 = 7
n |= n >>> 2;    0 1 1 1 | 0 0 0 1 = 0 1 1 1 = 7
n |= n >>> 4;    0 1 1 1 | 0 0 0 0 = 0 1 1 1 = 7
n |= n >>> 8;    0 1 1 1 | 0 0 0 0 = 0 1 1 1 = 7
n |= n >>> 16;   0 1 1 1 | 0 0 0 0 = 0 1 1 1 = 7
return n + 1     7 + 1 = 8 
</code></pre>
<p>æ‰€ä»¥è®¡ç®—å‡ºçš„å“ˆå¸Œè¡¨å®¹é‡æ˜¯ 8 = 2^3ï¼Œç„¶åå†æ ¹æ®<code>load factor * current capacity</code>è®¡ç®—å‡ºå½“å‰æœ‰æ•ˆå­˜å‚¨é‡ä¸º 6ï¼Œå¹¶å°† 6 èµ‹äºˆç»™ HashMap çš„å®ä¾‹å˜é‡ <code>threshold</code> ã€‚</p>
<pre><code class="language-java">int threshold;
</code></pre>
<p>è€Œå½“å“ˆå¸Œè¡¨çš„æ•°æ®æ¡æ•°å¤§äº 6 å°†ä¼šå‘ç”Ÿ rehashã€‚</p>
<pre><code class="language-java">if (++size > threshold)
    resize();
</code></pre>
<p>å“ˆå¸Œè¡¨çš„æ‰©å®¹è®¡ç®—æ–¹å¼å¾ˆç®€å•ï¼š</p>
<p> <code>newCap = oldCap &#x3C;&#x3C; 1</code>ï¼Œ<code>newThr = oldThr &#x3C;&#x3C; 1</code></p>
<h2>è®¡ç®—ä½ç½®(ä¸‹æ ‡)</h2>
<p>åˆ†ä¸ºä¸¤æ­¥ï¼Œé¦–å…ˆè®¡ç®—ä¸€æ¬¡ hashï¼Œåˆ©ç”¨ key çš„ hashcode é«˜åå…­ä½å’Œä½åå…­ä½è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼š</p>
<pre><code class="language-java">static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
</code></pre>
<p>ç„¶åæ˜¯ä¸‹æ ‡çš„è®¡ç®—ï¼Œn ä»£è¡¨å“ˆå¸Œè¡¨å®¹é‡ï¼Œå°†å‡†å¤‡å¥½çš„ hash å†æ¬¡è¿›è¡Œ <code>&#x26;</code> è¿ç®—ï¼Œ n-1 é¿å…æ•°ç»„è¶Šç•Œï¼š</p>
<pre><code class="language-java">i = (n - 1) &#x26; hash
</code></pre>
<p>å‡è®¾å“ˆå¸Œè¡¨å®¹é‡ä¸º 8ï¼Œå¹¶ä¸”å­˜å…¥ä¸€æ¡æ•°æ®ï¼š <code>map.put("abcabcabc", "")</code></p>
<pre><code class="language-java">h = key.hashCode(): 0001 0010 0100 0011 1011 0011 1010 0010 // "abcabcabc".hashCode();
                                      xor
h >>> 16:           0000 0000 0000 0000 0001 0010 0100 0011
                                      â†“â†“â†“
hash = h ^ h>>>16:  0001 0010 0100 0011 1010 0001 1110 0001
                                       &#x26;
n - 1:              0000 0000 0000 0000 0000 0000 0000 0111
                                      â†“â†“â†“
(n - 1) &#x26; hash:     0000 0000 0000 0000 0000 0000 0000 0001 // index = 1
</code></pre>
<p>å› æ­¤è®¡ç®—å‡º â€œabcabcabcâ€ è¿™ä¸ª key åœ¨å“ˆå¸Œè¡¨çš„ä½ç½®(ä¸‹æ ‡)æ˜¯ 1 ã€‚</p>
<p>å…³äº hash å‡½æ•°çš„è®¾è®¡ï¼Œä»£ç æ³¨é‡Šçš„è¯´æ³•æ˜¯ï¼š</p>
<blockquote>
<p>  Computes key.hashCode() and spreads (XORs) higher bits of hash to lower.  Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.)  So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don't benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.</p>
</blockquote>
<p>æ³¨é‡Šä¸­è¯´åˆ°ï¼Œå¤§å¤šæ•°çš„ hashCode çš„åˆ†å¸ƒå·²ç»éå¸¸åˆç†äº†ï¼Œå¦‚æœè¿˜å‘ç”Ÿå†²çªå°±ä½¿ç”¨é“¾è¡¨æˆ–è€…æ ‘ç»“æ„è§£å†³ï¼Œå› æ­¤è®¾è®¡è€…ä½¿ç”¨æœ€èŠ‚çœç³»ç»Ÿæ€§èƒ½å¼€é”€çš„ç§»ä½ä»¥åŠå¼‚æˆ–è¿ç®—æ¥é¿å…æ›´å¤šçš„å†²çªã€‚</p>
<p>ä½¿ç”¨ hash å‡½æ•°ï¼Œæ˜¯å› ä¸ºè¦è€ƒè™‘åˆ°ï¼Œå¦‚æœä½¿ç”¨çš„ hashCode ä»…åœ¨é«˜ä½ä¸åŒï¼Œè€Œä½ä½ç›¸åŒï¼Œé‚£ä¹ˆåœ¨æç«¯æƒ…å†µä¸‹å‘ç”Ÿå†²çªæ¦‚ç‡å°†å¢å¤§ã€‚</p>
<p>ä¾‹å¦‚ï¼š</p>
<pre><code class="language-java">hashCode 1:         1100 0011 1000 0011 1000 1010 0001 0000
hashCode 2:         0100 1011 0100 1100 1111 0110 1100 0000
hashCode 3:         0000 0001 1001 1001 0110 1011 1110 0000
                                       &#x26;
n - 1:              0000 0000 0000 0000 0000 0000 0000 0111
                                      â†“â†“â†“
(n - 1) &#x26; hashCode: 0000 0000 0000 0000 0000 0000 0000 0111 // Index is always the same: 7
</code></pre>
<p>å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœä¸‰ä¸ª hashCode çš„é«˜ä½ä¸åŒï¼Œè€Œä½ 3 ä½å®Œå…¨ç›¸åŒ(å…¨ä¸º 0)ï¼Œé‚£  <code>(n -1) &#x26; hashCode</code> è¿ç®—çš„ç»“æœéƒ½ç›¸åŒ (7)ï¼Œè¿™ç§æƒ…å†µæ‰€æœ‰çš„æ•°æ®éƒ½ä»¥é“¾è¡¨æˆ–è€…æ ‘ç»“æ„å½¢å¼å­˜åœ¨åŒä¸€ä½ç½® (7)ã€‚å¦‚æœå‘ç”Ÿæ›´å¤šå†²çªï¼Œæ—¶é—´å¤æ‚åº¦ä» O(1) å˜ä¸º O(n) æˆ–è€… O(log n)ï¼Œæ€§èƒ½å°±ä¼šæœ‰æ‰€é™ä½ã€‚</p>
<p>ä½¿ç”¨ XOR çš„åŸå› ï¼Œæ˜¯å› ä¸ºè¿™æ ·çš„è¿ç®—å¯ä½¿å¾— 1 å’Œ 0 å…·æœ‰ 50% / 50% çš„åˆ†å¸ƒï¼Œç›¸æ¯”äº <code>&#x26;</code> å’Œ <code>|</code> çš„ 25/75 å’Œ 75/25 æ›´åŠ å¹³å‡ã€ç¨³å®šã€‚</p>
<table>
<thead>
<tr>
<th>XOR</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>1 å’Œ 0 æ•°é‡å„å æ€»æ•°ä¸€åŠã€‚</p>
<table>
<thead>
<tr>
<th>&#x26;</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>1 å’Œ 0 æ•°é‡å„å æ€»æ•° 25% å’Œ 75%ã€‚</p>
<table>
<thead>
<tr>
<th>|</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>1 å’Œ 0 æ•°é‡å„å æ€»æ•° 75% å’Œ 25%ã€‚</p>
<h2>æ‰©å®¹(resize)</h2>
<p>å“ˆå¸Œè¡¨çš„åˆå§‹åŒ–ä¸æ‰©å®¹éƒ½ä½¿ç”¨åŒä¸€å¥—é€»è¾‘ï¼Œå³ <strong>java.util.HashMap#resize</strong> æ–¹æ³•ã€‚</p>
<pre><code class="language-java">final Node&#x3C;K,V>[] resize()
</code></pre>
<blockquote>
<p>Initializes or doubles table size.  If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.</p>
</blockquote>
<p>å¤§è‡´æ„æ€å°±æ˜¯è¯´ï¼Œå½“è¶…è¿‡é™åˆ¶çš„æ—¶å€™ä¼š resizeï¼Œç„¶è€Œåˆå› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯2æ¬¡å¹‚çš„æ‰©å±•(æŒ‡é•¿åº¦æ‰©ä¸ºåŸæ¥2å€)ï¼Œæ‰€ä»¥ï¼Œå…ƒç´ çš„ä½ç½®è¦ä¹ˆæ˜¯åœ¨åŸä½ç½®ï¼Œè¦ä¹ˆæ˜¯åœ¨åŸä½ç½®å†ç§»åŠ¨2æ¬¡å¹‚çš„ä½ç½®ã€‚</p>
<p><img src="https://resource.1024kb.top/image/code-sample/hashmap-resize.png" alt="git-rebase.gif"></p>
<p>è§‚å¯Ÿä¸Šå›¾æ‰©å®¹å(8 -> 16)çš„æ•°æ®åˆ†å¸ƒï¼Œè¦ä¹ˆæ˜¯æ”¹å˜äº†ç´¢å¼•ï¼Œè¦ä¹ˆæ˜¯ä¸å˜ï¼Œæ”¹å˜çš„å°±æ˜¯ç§»åŠ¨2æ¬¡å¹‚çš„ä½ç½®(+8)ã€‚</p>
<pre><code class="language-java">5 + 8 = 13
    4 = 4
0 + 8 = 8
</code></pre>
<p>å†æ¬¡æ‰©å®¹äº¦æ˜¯å¦‚æ­¤ï¼Œå¦‚ 16 -> 32 ï¼Œé‚£ä¹ˆæ”¹å˜çš„ä¹Ÿæ˜¯ç§»åŠ¨2æ¬¡å¹‚çš„ä½ç½®(+16)ã€‚</p>
<pre><code class="language-java">13 + 16 = 29
4  + 16 = 20
8  + 16 = 24
</code></pre>
<p>å¯¹äºæ˜¯å¦éœ€è¦æ”¹å˜ç´¢å¼•ï¼Œåªéœ€è¦çœ‹çœ‹åŸæ¥çš„ hash å€¼æ–°å¢çš„é‚£ä¸ª bit æ˜¯ 1 è¿˜æ˜¯ 0 å°±å¥½äº†ï¼Œæ˜¯ 0 åˆ™æ— éœ€æ”¹å˜ä½ç½®ã€‚ä¾‹å¦‚ä¸Šå›¾çš„ hash2ï¼Œæ‰©å®¹åç”± <code>100</code> å˜ä¸º <code>0100</code>ï¼Œå¤šå‡ºçš„ä¸€ä½æ•°æ˜¯ 0ï¼Œé‚£ä¹ˆ 0 å’Œå…¶å®ƒæ•°å­—è¿›è¡Œä¸è¿ç®—éƒ½æ˜¯ 0ã€‚</p>
<pre><code class="language-java">hash2:   100
          &#x26;
n = 8:   111 
          â†“
         100 = 4
--------------------
hash2:  0100
          &#x26;
n = 16: 1111
          â†“
        0100 = 4
</code></pre>
<h2>å–æ•°æ®(get)</h2>
<p>åœ¨ç†è§£ä»¥ä¸Šé€»è¾‘ä¹‹åï¼Œget å°±å¾ˆç®€å•äº†ã€‚å¤§è‡´æ€è·¯å¦‚ä¸‹ï¼š</p>
<ol>
<li>æ ¹æ® key çš„ hashCode è¿›è¡Œä¸€æ¬¡ hash</li>
<li>åˆ©ç”¨ <code>(n - 1) &#x26; hash</code> è®¡ç®—å‡ºå®é™…ä½ç½®(ç´¢å¼•)</li>
<li>å¦‚æœæ ¹æ®ç´¢å¼•ç›´æ¥åŒ¹é…åˆ°ï¼Œç›´æ¥è¿”å›ï¼Œ O(1)</li>
<li>å¦‚æœæ ¹æ®ç´¢å¼•æœªèƒ½åŒ¹é…åˆ°<ul>
<li>è‹¥ä¸ºæ ‘ï¼Œåˆ™ä½¿ç”¨æŸ¥è¯¢æ ‘çš„æ“ä½œï¼ŒO(logn)</li>
<li>è‹¥ä¸ºé“¾è¡¨ï¼Œåˆ™å¾ªç¯é“¾è¡¨æŸ¥æ‰¾ï¼ŒO(n)</li>
</ul></li>
</ol>
<h2>æµ‹è¯•</h2>
<p>åˆ©ç”¨ benchmark æµ‹è¯•å·¥å…·æ¥æµ‹è¯• HashMapï¼Œåœ¨åˆå§‹åŒ–æŒ‡å®šå®¹é‡ä¸ä½¿ç”¨é»˜è®¤æ„é€ å‡½æ•°çš„æ€§èƒ½åŒºåˆ«ã€‚</p>
<p>æµ‹è¯•åˆ†ä¸º 5 ä¸ªç­‰çº§ï¼š</p>
<ol>
<li>æ·»åŠ ä¸åŒçš„æ•°æ®ç›´åˆ°æ»¡è¶³ 16 æ¡</li>
<li>æ·»åŠ ä¸åŒçš„æ•°æ®ç›´åˆ°æ»¡è¶³ 100 æ¡</li>
<li>æ·»åŠ ä¸åŒçš„æ•°æ®ç›´åˆ°æ»¡è¶³ 1000 æ¡</li>
<li>æ·»åŠ ä¸åŒçš„æ•°æ®ç›´åˆ°æ»¡è¶³ 10000 æ¡</li>
<li>æ·»åŠ ä¸åŒçš„æ•°æ®ç›´åˆ°æ»¡è¶³ 100000 æ¡</li>
</ol>
<p>ä½¿ç”¨é»˜è®¤æ„é€ å‡½æ•°ï¼š</p>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Mode</th>
<th>Cnt</th>
<th>Score</th>
<th>Error</th>
<th>Units</th>
</tr>
</thead>
<tbody>
<tr>
<td>MapBenchmark.measure_level1</td>
<td>thrpt</td>
<td>5</td>
<td>141991260.547 Â±  419002.953</td>
<td></td>
<td>ops/s</td>
</tr>
<tr>
<td>MapBenchmark.measure_level2</td>
<td>thrpt</td>
<td>5</td>
<td>66501311.793 Â± 5285311.107</td>
<td></td>
<td>ops/s</td>
</tr>
<tr>
<td>MapBenchmark.measure_level3</td>
<td>thrpt</td>
<td>5</td>
<td>70077920.597 Â± 6574269.856</td>
<td></td>
<td>ops/s</td>
</tr>
<tr>
<td>MapBenchmark.measure_level4</td>
<td>thrpt</td>
<td>5</td>
<td>58270016.113 Â± 3106384.470</td>
<td></td>
<td>ops/s</td>
</tr>
<tr>
<td>MapBenchmark.measure_level5</td>
<td>thrpt</td>
<td>5</td>
<td>25518813.878 Â± 1097213.863</td>
<td></td>
<td>ops/s</td>
</tr>
</tbody>
</table>
<p>ä½¿ç”¨åˆå§‹åŒ–å®¹é‡çš„æ„é€ å‡½æ•°ï¼Œå¹¶ä¸”è€ƒè™‘å®é™…æ•°æ®é‡ä¼ å…¥åˆç†çš„å‚æ•°ï¼š</p>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Mode</th>
<th>Cnt</th>
<th>Score</th>
<th>Error</th>
<th>Units</th>
</tr>
</thead>
<tbody>
<tr>
<td>MapBenchmark.measure_level1</td>
<td>thrpt</td>
<td>5</td>
<td>122338131.327 Â±  9689798.828</td>
<td></td>
<td>ops/s</td>
</tr>
<tr>
<td>MapBenchmark.measure_level2</td>
<td>thrpt</td>
<td>5</td>
<td>102039334.216 Â±  2403155.914</td>
<td></td>
<td>ops/s</td>
</tr>
<tr>
<td>MapBenchmark.measure_level3</td>
<td>thrpt</td>
<td>5</td>
<td>96752178.779 Â±  4839327.658</td>
<td></td>
<td>ops/s</td>
</tr>
<tr>
<td>MapBenchmark.measure_level4</td>
<td>thrpt</td>
<td>5</td>
<td>88239132.356 Â±  9597356.077</td>
<td></td>
<td>ops/s</td>
</tr>
<tr>
<td>MapBenchmark.measure_level5</td>
<td>thrpt</td>
<td>5</td>
<td>55940080.977 Â± 13094145.548</td>
<td></td>
<td>ops/s</td>
</tr>
</tbody>
</table>
<p>å…³æ³¨ Score çš„ç»“æœï¼Œå®ƒä»¬éƒ½æ˜¯ xxx Â± xxxï¼ŒUnits ä»£è¡¨å•ä½æ¯ç§’å¤šå°‘æ¬¡æ“ä½œã€‚</p>
<p>å¯ä»¥çœ‹åˆ°æ— è®ºå“ªç§åˆå§‹åŒ–æ“ä½œï¼Œéšç€æ•°æ®é‡å¢å¤§ï¼Œæ¯ç§’æ“ä½œæ¬¡æ•°éƒ½éšä¹‹é™ä½ã€‚è€ŒåŒæ ·æ¡ä»¶ä¸‹ï¼Œä½¿ç”¨<strong>åˆå§‹åŒ–å®¹é‡çš„æ„é€ å‡½æ•°</strong>ç›¸æ¯”ä½¿ç”¨<strong>é»˜è®¤æ„é€ å‡½æ•°</strong>ï¼Œå‰è€…æ€§èƒ½æ›´ä½³ã€‚</p>
<h1>é™„å½•</h1>
<p> benchmark æµ‹è¯•ä»£ç ã€‚</p>
<pre><code class="language-java">@State(Scope.Thread)
public class MapBenchmark {

  String[] resource;

  @Setup()
  public void prepare() {
      resource = new String[100000];
      for (int i = 0; i &#x3C; resource.length; i++) {
          resource[i] = String.valueOf(i);
      }
  }

  private Map&#x3C;String, String> reps(int reps) {
      // Map&#x3C;String, String> map = new HashMap&#x3C;>((int) ((float) reps / 0.75F + 1.0F)); // ä½¿ç”¨åˆå§‹åŒ–å®¹é‡çš„æ„é€ å‡½æ•°
      Map&#x3C;String, String> map = new HashMap&#x3C;>(); // ä½¿ç”¨é»˜è®¤æ„é€ å‡½æ•°

      for (int i = 0; i &#x3C; reps; i++) {
          String test = resource[i];
          map.put(test, test);
      }
      return map;
  }

  @Benchmark
  @OperationsPerInvocation(10)
  public Map&#x3C;String, String> measure_level1() {
      return reps(10);
  }

  @Benchmark
  @OperationsPerInvocation(100)
  public Map&#x3C;String, String> measure_level2() {
      return reps(100);
  }

  @Benchmark
  @OperationsPerInvocation(1000)
  public Map&#x3C;String, String> measure_level3() {
      return reps(1000);
  }

  @Benchmark
  @OperationsPerInvocation(10000)
  public Map&#x3C;String, String> measure_level4() {
      return reps(10_000);
  }

  @Benchmark
  @OperationsPerInvocation(100000)
  public Map&#x3C;String, String> measure_level5() {
      return reps(100_000);
  }

  public static void main(String[] args) throws RunnerException {
      Options opt = new OptionsBuilder()
              .include(MapBenchmark.class.getSimpleName())
              .forks(1)
              .build();
      new Runner(opt).run();
  }

}
</code></pre>
<p>ä½¿ç”¨é»˜è®¤æ„é€ å‡½æ•°çš„æµ‹è¯•ç»“æœã€‚</p>
<pre><code class="language-java"># JMH version: 1.23
# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11
# VM invoker: C:\Program Files\Java\jdk1.8.0_221\jre\bin\java.exe
# VM options: -javaagent:E:\app\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=53301:E:\app\IntelliJ IDEA 2019.1.4\bin -Dfile.encoding=UTF-8
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: tester.MapBenchmark.measure_level1

# Run progress: 0.00% complete, ETA 00:08:20
# Fork: 1 of 1
# Warmup Iteration   1: 127001625.901 ops/s
# Warmup Iteration   2: 141822524.390 ops/s
# Warmup Iteration   3: 133428241.333 ops/s
# Warmup Iteration   4: 132244469.411 ops/s
# Warmup Iteration   5: 138276778.513 ops/s
Iteration   1: 141895511.199 ops/s
Iteration   2: 141923059.081 ops/s
Iteration   3: 142158823.597 ops/s
Iteration   4: 141937212.493 ops/s
Iteration   5: 142041696.363 ops/s


Result "tester.MapBenchmark.measure_level1":
  141991260.547 Â±(99.9%) 419002.953 ops/s [Average]
  (min, avg, max) = (141895511.199, 141991260.547, 142158823.597), stdev = 108813.736
  CI (99.9%): [141572257.593, 142410263.500] (assumes normal distribution)


# JMH version: 1.23
# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11
# VM invoker: C:\Program Files\Java\jdk1.8.0_221\jre\bin\java.exe
# VM options: -javaagent:E:\app\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=53301:E:\app\IntelliJ IDEA 2019.1.4\bin -Dfile.encoding=UTF-8
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: tester.MapBenchmark.measure_level2

# Run progress: 20.00% complete, ETA 00:06:43
# Fork: 1 of 1
# Warmup Iteration   1: 66265103.610 ops/s
# Warmup Iteration   2: 66389800.461 ops/s
# Warmup Iteration   3: 67855747.609 ops/s
# Warmup Iteration   4: 67289955.476 ops/s
# Warmup Iteration   5: 67750553.602 ops/s
Iteration   1: 67298893.171 ops/s
Iteration   2: 66615628.545 ops/s
Iteration   3: 64314592.829 ops/s
Iteration   4: 66334869.364 ops/s
Iteration   5: 67942575.053 ops/s


Result "tester.MapBenchmark.measure_level2":
  66501311.793 Â±(99.9%) 5285311.107 ops/s [Average]
  (min, avg, max) = (64314592.829, 66501311.793, 67942575.053), stdev = 1372578.510
  CI (99.9%): [61216000.685, 71786622.900] (assumes normal distribution)


# JMH version: 1.23
# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11
# VM invoker: C:\Program Files\Java\jdk1.8.0_221\jre\bin\java.exe
# VM options: -javaagent:E:\app\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=53301:E:\app\IntelliJ IDEA 2019.1.4\bin -Dfile.encoding=UTF-8
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: tester.MapBenchmark.measure_level3

# Run progress: 40.00% complete, ETA 00:05:02
# Fork: 1 of 1
# Warmup Iteration   1: 67605636.507 ops/s
# Warmup Iteration   2: 69621052.760 ops/s
# Warmup Iteration   3: 71010248.192 ops/s
# Warmup Iteration   4: 69532881.868 ops/s
# Warmup Iteration   5: 71013446.760 ops/s
Iteration   1: 70574046.109 ops/s
Iteration   2: 70965533.458 ops/s
Iteration   3: 71067189.031 ops/s
Iteration   4: 70739591.373 ops/s
Iteration   5: 67043243.012 ops/s


Result "tester.MapBenchmark.measure_level3":
  70077920.597 Â±(99.9%) 6574269.856 ops/s [Average]
  (min, avg, max) = (67043243.012, 70077920.597, 71067189.031), stdev = 1707317.004
  CI (99.9%): [63503650.740, 76652190.453] (assumes normal distribution)


# JMH version: 1.23
# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11
# VM invoker: C:\Program Files\Java\jdk1.8.0_221\jre\bin\java.exe
# VM options: -javaagent:E:\app\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=53301:E:\app\IntelliJ IDEA 2019.1.4\bin -Dfile.encoding=UTF-8
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: tester.MapBenchmark.measure_level4

# Run progress: 60.00% complete, ETA 00:03:21
# Fork: 1 of 1
# Warmup Iteration   1: 58376736.170 ops/s
# Warmup Iteration   2: 56309258.446 ops/s
# Warmup Iteration   3: 58577905.930 ops/s
# Warmup Iteration   4: 58987213.188 ops/s
# Warmup Iteration   5: 56652677.235 ops/s
Iteration   1: 56883247.928 ops/s
Iteration   2: 58521062.413 ops/s
Iteration   3: 58301230.510 ops/s
Iteration   4: 58767115.865 ops/s
Iteration   5: 58877423.848 ops/s


Result "tester.MapBenchmark.measure_level4":
  58270016.113 Â±(99.9%) 3106384.470 ops/s [Average]
  (min, avg, max) = (56883247.928, 58270016.113, 58877423.848), stdev = 806718.182
  CI (99.9%): [55163631.643, 61376400.583] (assumes normal distribution)


# JMH version: 1.23
# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11
# VM invoker: C:\Program Files\Java\jdk1.8.0_221\jre\bin\java.exe
# VM options: -javaagent:E:\app\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=53301:E:\app\IntelliJ IDEA 2019.1.4\bin -Dfile.encoding=UTF-8
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: tester.MapBenchmark.measure_level5

# Run progress: 80.00% complete, ETA 00:01:40
# Fork: 1 of 1
# Warmup Iteration   1: 24666505.202 ops/s
# Warmup Iteration   2: 25541321.825 ops/s
# Warmup Iteration   3: 25787825.310 ops/s
# Warmup Iteration   4: 25812122.914 ops/s
# Warmup Iteration   5: 25673018.223 ops/s
Iteration   1: 25745027.348 ops/s
Iteration   2: 25655260.447 ops/s
Iteration   3: 25747293.453 ops/s
Iteration   4: 25341679.313 ops/s
Iteration   5: 25104808.828 ops/s


Result "tester.MapBenchmark.measure_level5":
  25518813.878 Â±(99.9%) 1097213.863 ops/s [Average]
  (min, avg, max) = (25104808.828, 25518813.878, 25747293.453), stdev = 284942.956
  CI (99.9%): [24421600.015, 26616027.741] (assumes normal distribution)


# Run complete. Total time: 00:08:23

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                     Mode  Cnt          Score         Error  Units
MapBenchmark.measure_level1  thrpt    5  141991260.547 Â±  419002.953  ops/s
MapBenchmark.measure_level2  thrpt    5   66501311.793 Â± 5285311.107  ops/s
MapBenchmark.measure_level3  thrpt    5   70077920.597 Â± 6574269.856  ops/s
MapBenchmark.measure_level4  thrpt    5   58270016.113 Â± 3106384.470  ops/s
MapBenchmark.measure_level5  thrpt    5   25518813.878 Â± 1097213.863  ops/s

Process finished with exit code 0
</code></pre>
<p>ä½¿ç”¨åˆå§‹åŒ–æ„é€ å‡½æ•°çš„æµ‹è¯•ç»“æœã€‚</p>
<pre><code class="language-java"># JMH version: 1.23
# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11
# VM invoker: C:\Program Files\Java\jdk1.8.0_221\jre\bin\java.exe
# VM options: -javaagent:E:\app\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=53688:E:\app\IntelliJ IDEA 2019.1.4\bin -Dfile.encoding=UTF-8
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: tester.MapBenchmark.measure_level1

# Run progress: 0.00% complete, ETA 00:08:20
# Fork: 1 of 1
# Warmup Iteration   1: 118482946.186 ops/s
# Warmup Iteration   2: 112336132.574 ops/s
# Warmup Iteration   3: 118383971.447 ops/s
# Warmup Iteration   4: 116669575.125 ops/s
# Warmup Iteration   5: 119473270.826 ops/s
Iteration   1: 121741335.641 ops/s
Iteration   2: 124303130.157 ops/s
Iteration   3: 124904353.757 ops/s
Iteration   4: 118528835.278 ops/s
Iteration   5: 122213001.803 ops/s


Result "tester.MapBenchmark.measure_level1":
  122338131.327 Â±(99.9%) 9689798.828 ops/s [Average]
  (min, avg, max) = (118528835.278, 122338131.327, 124904353.757), stdev = 2516409.984
  CI (99.9%): [112648332.499, 132027930.155] (assumes normal distribution)


# JMH version: 1.23
# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11
# VM invoker: C:\Program Files\Java\jdk1.8.0_221\jre\bin\java.exe
# VM options: -javaagent:E:\app\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=53688:E:\app\IntelliJ IDEA 2019.1.4\bin -Dfile.encoding=UTF-8
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: tester.MapBenchmark.measure_level2

# Run progress: 20.00% complete, ETA 00:06:43
# Fork: 1 of 1
# Warmup Iteration   1: 93315434.143 ops/s
# Warmup Iteration   2: 92983341.778 ops/s
# Warmup Iteration   3: 97101517.219 ops/s
# Warmup Iteration   4: 92564247.846 ops/s
# Warmup Iteration   5: 100285038.019 ops/s
Iteration   1: 102162049.729 ops/s
Iteration   2: 102379826.993 ops/s
Iteration   3: 102475922.945 ops/s
Iteration   4: 100944632.787 ops/s
Iteration   5: 102234238.627 ops/s


Result "tester.MapBenchmark.measure_level2":
  102039334.216 Â±(99.9%) 2403155.914 ops/s [Average]
  (min, avg, max) = (100944632.787, 102039334.216, 102475922.945), stdev = 624091.959
  CI (99.9%): [99636178.302, 104442490.130] (assumes normal distribution)


# JMH version: 1.23
# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11
# VM invoker: C:\Program Files\Java\jdk1.8.0_221\jre\bin\java.exe
# VM options: -javaagent:E:\app\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=53688:E:\app\IntelliJ IDEA 2019.1.4\bin -Dfile.encoding=UTF-8
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: tester.MapBenchmark.measure_level3

# Run progress: 40.00% complete, ETA 00:05:02
# Fork: 1 of 1
# Warmup Iteration   1: 97822881.423 ops/s
# Warmup Iteration   2: 95718868.583 ops/s
# Warmup Iteration   3: 97607085.636 ops/s
# Warmup Iteration   4: 95961881.083 ops/s
# Warmup Iteration   5: 96181959.004 ops/s
Iteration   1: 97486071.647 ops/s
Iteration   2: 97317494.401 ops/s
Iteration   3: 97341695.379 ops/s
Iteration   4: 97097857.201 ops/s
Iteration   5: 94517775.269 ops/s


Result "tester.MapBenchmark.measure_level3":
  96752178.779 Â±(99.9%) 4839327.658 ops/s [Average]
  (min, avg, max) = (94517775.269, 96752178.779, 97486071.647), stdev = 1256758.025
  CI (99.9%): [91912851.122, 101591506.437] (assumes normal distribution)


# JMH version: 1.23
# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11
# VM invoker: C:\Program Files\Java\jdk1.8.0_221\jre\bin\java.exe
# VM options: -javaagent:E:\app\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=53688:E:\app\IntelliJ IDEA 2019.1.4\bin -Dfile.encoding=UTF-8
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: tester.MapBenchmark.measure_level4

# Run progress: 60.00% complete, ETA 00:03:21
# Fork: 1 of 1
# Warmup Iteration   1: 92047944.166 ops/s
# Warmup Iteration   2: 89678443.566 ops/s
# Warmup Iteration   3: 89812773.142 ops/s
# Warmup Iteration   4: 88930887.557 ops/s
# Warmup Iteration   5: 85792676.395 ops/s
Iteration   1: 89347289.220 ops/s
Iteration   2: 89191963.589 ops/s
Iteration   3: 83800965.269 ops/s
Iteration   4: 89119847.919 ops/s
Iteration   5: 89735595.781 ops/s


Result "tester.MapBenchmark.measure_level4":
  88239132.356 Â±(99.9%) 9597356.077 ops/s [Average]
  (min, avg, max) = (83800965.269, 88239132.356, 89735595.781), stdev = 2492402.896
  CI (99.9%): [78641776.279, 97836488.433] (assumes normal distribution)


# JMH version: 1.23
# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11
# VM invoker: C:\Program Files\Java\jdk1.8.0_221\jre\bin\java.exe
# VM options: -javaagent:E:\app\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=53688:E:\app\IntelliJ IDEA 2019.1.4\bin -Dfile.encoding=UTF-8
# Warmup: 5 iterations, 10 s each
# Measurement: 5 iterations, 10 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Throughput, ops/time
# Benchmark: tester.MapBenchmark.measure_level5

# Run progress: 80.00% complete, ETA 00:01:40
# Fork: 1 of 1
# Warmup Iteration   1: 54077395.641 ops/s
# Warmup Iteration   2: 59732722.907 ops/s
# Warmup Iteration   3: 53583150.778 ops/s
# Warmup Iteration   4: 59899100.161 ops/s
# Warmup Iteration   5: 60709074.795 ops/s
Iteration   1: 60754432.284 ops/s
Iteration   2: 51357719.856 ops/s
Iteration   3: 55849596.896 ops/s
Iteration   4: 54854535.391 ops/s
Iteration   5: 56884120.457 ops/s


Result "tester.MapBenchmark.measure_level5":
  55940080.977 Â±(99.9%) 13094145.548 ops/s [Average]
  (min, avg, max) = (51357719.856, 55940080.977, 60754432.284), stdev = 3400508.017
  CI (99.9%): [42845935.429, 69034226.525] (assumes normal distribution)


# Run complete. Total time: 00:08:23

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.

Benchmark                     Mode  Cnt          Score          Error  Units
MapBenchmark.measure_level1  thrpt    5  122338131.327 Â±  9689798.828  ops/s
MapBenchmark.measure_level2  thrpt    5  102039334.216 Â±  2403155.914  ops/s
MapBenchmark.measure_level3  thrpt    5   96752178.779 Â±  4839327.658  ops/s
MapBenchmark.measure_level4  thrpt    5   88239132.356 Â±  9597356.077  ops/s
MapBenchmark.measure_level5  thrpt    5   55940080.977 Â± 13094145.548  ops/s

Process finished with exit code 0
</code></pre>
<h1>å‚è€ƒèµ„æ–™</h1>
<ul>
<li>Oracle, Class HashMap, <em>Oracle Java Documentation</em>. <a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">ğŸ“„</a></li>
<li>Yikun, Java-HashMapå·¥ä½œåŸç†åŠå®ç°, <em>Yikunâ€™s</em> Blog, 2015. <a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/">ğŸ“„</a></li>
<li>ç¾å›¢, Java 8ç³»åˆ—ä¹‹é‡æ–°è®¤è¯†HashMap, <em>ç¾å›¢æŠ€æœ¯å›¢é˜Ÿ</em>, 2015. <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">ğŸ“„</a></li>
<li>Aniket Thakur, â€œWhy HashMap insert new Node on index (n - 1) &#x26; hash?â€, <em>Stack Overflow</em>, 2017. <a href="https://stackoverflow.com/a/44615382">ğŸ“„</a></li>
<li>Jul, "Why return (h = key.hashCode()) ^ (h >>> 16) other than key.hashcode?", <em>Stack Overflow</em>, 2017. <a href="https://stackoverflow.com/a/45140621">ğŸ“„</a></li>
<li>Andy Turner, "HashMap.tableSizeFor(â€¦). How does this code round up to the next power of 2?", <em>Stack Overflow</em>, 2018. <a href="https://stackoverflow.com/a/51121765">ğŸ“„</a></li>
<li>Mincong Huang, learning-hashmap, <em>Mincong Huangâ€™s</em> Blog, 2019. <a href="https://mincong.io/2018/04/08/learning-hashmap/">ğŸ“„</a></li>
<li>é£æ±¡ç†Šåšå®¢, Javaå¾®åŸºå‡†æµ‹è¯•æ¡†æ¶JMH, <em>é£æ±¡ç†Šåšå®¢â€™s</em> Blog, 2018. <a href="https://www.xncoding.com/2018/01/07/java/jmh.html">ğŸ“„</a></li>
<li>Jakob Jenkov, JMH - Java Microbenchmark Harness, <em>Jakob Jenkov's</em> Blog, 2015. <a href="http://tutorials.jenkov.com/java-performance/jmh.html">ğŸ“„</a></li>
<li>jhm samples. <a href="https://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/">ğŸ“„</a></li>
</ul>
</div></div></div><div style="position:fixed;bottom:150px;right:50px"><nav id="posts-nav"><ul style="list-style:none"></ul></nav></div><div class="ant-row ant-row-center" style="margin-bottom:40px;margin-top:40px"><span class="ant-typography"><u>Â· last updatedï¼š<!-- --> Â·</u></span></div></div></div><span style="position:fixed;bottom:60px;right:15px;z-index:999;background-color:#555555" class="ant-avatar ant-avatar-lg ant-avatar-circle ant-avatar-icon ant-dropdown-trigger"><span role="img" aria-label="unordered-list" class="anticon anticon-unordered-list"><svg viewBox="64 64 896 896" focusable="false" class="" data-icon="unordered-list" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z"></path></svg></span></span><div style="display:none" class="web-map"><a href="/">ä¸»é¡µ</a><a href="/notes">ç¬”è®°</a></div></main><footer class="ant-layout-footer ki-footer"><a href="http://www.beian.miit.gov.cn" target="_blank" style="color:rgba(250, 250, 250, 0.938)">æ¡‚ICPå¤‡18000815å·-2 Â© 2017 - 2020 - KIYAK-WEB</a></footer></section></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"filename":"programming/[Java]HashMapåŸç†ç®€æ.md","title":"HashMapåŸç†ç®€æ","date":"2020-06-06T14:02:00.000Z","updated":"2020-06-06T14:02:00.000Z","preText":"ğŸ’ª","preTextColor":"rgb(230, 230, 230)","status":null,"statusColor":null,"content":"\u003ch1\u003eHashMapåŸç†ç®€æ\u003c/h1\u003e\n\u003ch2\u003eæ¦‚è¿°\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933\"\u003eæ•£åˆ—è¡¨\u003c/a\u003eï¼ˆHash tableï¼Œä¹Ÿå«å“ˆå¸Œè¡¨ï¼‰ï¼Œæ˜¯æ ¹æ®å…³é”®ç å€¼(Key value)è€Œç›´æ¥è¿›è¡Œè®¿é—®çš„\u003ca href=\"https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450\"\u003eæ•°æ®ç»“æ„\u003c/a\u003eã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒé€šè¿‡æŠŠå…³é”®ç å€¼æ˜ å°„åˆ°è¡¨ä¸­ä¸€ä¸ªä½ç½®æ¥è®¿é—®è®°å½•ï¼Œä»¥åŠ å¿«æŸ¥æ‰¾çš„é€Ÿåº¦ã€‚è¿™ä¸ªæ˜ å°„å‡½æ•°å«åš\u003ca href=\"https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288\"\u003eæ•£åˆ—å‡½æ•°\u003c/a\u003eï¼Œå­˜æ”¾è®°å½•çš„\u003ca href=\"https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097\"\u003eæ•°ç»„\u003c/a\u003eå«åš\u003ca href=\"https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933\"\u003eæ•£åˆ—è¡¨\u003c/a\u003eã€‚\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003eHashMap\u003c/strong\u003e æ˜¯ Java é¡¹ç›®å¼€å‘è€…ä½¿ç”¨é¢‘ç‡æœ€é«˜çš„å·¥å…·ç±»ä¹‹ä¸€ï¼Œå®ƒå†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªå“ˆå¸Œè¡¨ï¼Œç”¨äºæ˜ å°„(é”®å€¼å¯¹)å¤„ç†çš„æ•°æ®ç±»å‹ï¼Œå¯ä»¥è¯´ HashMap åœ¨é¡¹ç›®ä»£ç ä¸­å‡ ä¹éšå¤„å¯è§ã€‚\u003c/p\u003e\n\u003ch2\u003eè¦ç‚¹\u003c/h2\u003e\n\u003cp\u003eå®˜æ–¹\u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html\"\u003eæ–‡æ¡£\u003c/a\u003eé‡Œå·²ç»å¯¹ HashMap è¿›è¡Œäº†æè¿°ï¼Œå¤§è‡´æœ‰ä¸‹åˆ— 5 ä¸ªè¦ç‚¹ï¼š\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eå…è®¸ \u003ccode\u003enull\u003c/code\u003e å€¼ä¸ \u003ccode\u003enull\u003c/code\u003e key\u003c/li\u003e\n\u003cli\u003eæ— æ³•ä¿è¯é¡ºåº\u003c/li\u003e\n\u003cli\u003eå½±å“æ€§èƒ½çš„ä¸¤ä¸ªå› ç´ ï¼š\u003cem\u003ecapacity\u003c/em\u003e å’Œ \u003cem\u003eload factor\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eä¸ä¿è¯çº¿ç¨‹åŒæ­¥\u003c/li\u003e\n\u003cli\u003eå…·å¤‡ \u003cem\u003efail-fast\u003c/em\u003e ä¿æŠ¤æœºåˆ¶\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cem\u003ecapacity\u003c/em\u003e æŒ‡çš„æ˜¯å“ˆå¸Œè¡¨çš„å®¹é‡ï¼Œ \u003cem\u003eload factor\u003c/em\u003e æŒ‡çš„æ˜¯å“ˆå¸Œè¡¨çš„è´Ÿè½½å› å­ï¼Œå…³äºè¿™ä¸¤ä¸ªå˜é‡çš„å…³ç³»ï¼Œå®˜æ–¹çš„æè¿°æ˜¯ï¼š\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe \u003cem\u003eload factor\u003c/em\u003e is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is \u003cstrong\u003e\u003cem\u003erehashed\u003c/em\u003e\u003c/strong\u003e (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAs a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the \u003ccode\u003eHashMap\u003c/code\u003e class, including \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003eput\u003c/code\u003e). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity,\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eç®€è€Œè¨€ä¹‹ï¼š\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eåªè¦æ»¡è¶³æ¡ä»¶ \u003ccode\u003eæ€»æ•°æ®é‡ \u003e load factor * current capacity\u003c/code\u003eï¼ŒHashMap å†…éƒ¨çš„å“ˆå¸Œè¡¨å°±ä¼šè¢«é‡æ„ (ç®€ç§° rehash)ï¼Œå“ˆå¸Œè¡¨å®¹é‡æ‰©å¤§è‡³åŸæ¥çš„ 2 å€ã€‚\u003c/li\u003e\n\u003cli\u003eä¸ºé¿å…å“ˆå¸Œè¡¨ rehash å¸¦æ¥çš„æ€§èƒ½æŸè€—ï¼Œå»ºè®®è€ƒè™‘åˆå§‹å®¹é‡å¤§å° \u003cem\u003einitial capacity\u003c/em\u003eã€‚\u003c/li\u003e\n\u003cli\u003e\u003cem\u003eload factor\u003c/em\u003e é»˜è®¤å€¼æ˜¯ 0.75ï¼Œè¯¥å€¼çš„å®šä¹‰æƒè¡¡äº†æ—¶é—´ä¸ç©ºé—´çš„æˆæœ¬ï¼Œè®¾ç½®å¤ªé«˜æˆ–è€…å¤ªä½éƒ½ä¼šå¯¼è‡´æ€§èƒ½å¤±è¡¡ã€‚\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eåˆå§‹åŒ–\u003c/h2\u003e\n\u003cp\u003eHashMap æä¾›å››ä¸ªæ„é€ å‡½æ•°ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic HashMap() // é»˜è®¤\npublic HashMap(int initialCapacity) // æŒ‡å®šåˆå§‹åŒ–å®¹é‡\npublic HashMap(int initialCapacity, float loadFactor) // æŒ‡å®šåˆå§‹åŒ–å®¹é‡ã€è´Ÿè½½å› å­\npublic HashMap(Map\u0026#x3C;? extends K, ? extends V\u003e m) // åˆå§‹åŒ–å¹¶ä¸”å¤åˆ¶å¦å¤–ä¸€ä¸ª Map\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå¦‚æœæœªæŒ‡å®š \u003ccode\u003einitialCapacity\u003c/code\u003eï¼Œé‚£ä¹ˆ (åˆå§‹) å“ˆå¸Œè¡¨å®¹é‡é»˜è®¤æ˜¯ \u003cstrong\u003e16\u003c/strong\u003eï¼Œå¦‚æœæœªæŒ‡å®š \u003ccode\u003eloadFactor\u003c/code\u003eï¼Œé‚£ä¹ˆè´Ÿè½½å› å­é»˜è®¤æ˜¯ \u003cstrong\u003e0.75\u003c/strong\u003eã€‚æ­£å¸¸æƒ…å†µä¸‹ï¼Œå¼€å‘äººå‘˜æ— éœ€æ”¹åŠ¨ \u003ccode\u003eloadFactor\u003c/code\u003e æ•°å€¼ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003estatic final int DEFAULT_INITIAL_CAPACITY = 1 \u0026#x3C;\u0026#x3C; 4; // aka 16\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ ¹æ® HashMap çš„æ–‡æ¡£æ‰€è¿°ï¼Œå¯é€šè¿‡é¢„ä¼°éœ€è¦å­˜å‚¨çš„æ•°æ®é‡ï¼Œæ¥é¿å…ä¸å¿…è¦çš„ rehashã€‚\u003ca href=\"https://github.com/alibaba/p3c\"\u003eé˜¿é‡Œå·´å·´Javaå¼€å‘æ‰‹å†Œ\u003c/a\u003eä¹Ÿé’ˆå¯¹è¿™ç§æƒ…å†µè¿›è¡Œäº†æè¿°ï¼š\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eè¯´æ˜ï¼šHashMap ä½¿ç”¨ HashMap(int initialCapacity) åˆå§‹åŒ–ï¼Œå¦‚æœæš‚æ—¶æ— æ³•ç¡®å®šé›†åˆå¤§å°ï¼Œé‚£ä¹ˆæŒ‡å®šé»˜è®¤å€¼ï¼ˆ16ï¼‰å³å¯ã€‚\u003cbr\u003e\næ­£ä¾‹ï¼šinitialCapacity = (éœ€è¦å­˜å‚¨çš„å…ƒç´ ä¸ªæ•° / è´Ÿè½½å› å­) + 1ã€‚æ³¨æ„è´Ÿè½½å› å­ï¼ˆå³ loader factorï¼‰é»˜è®¤ä¸º 0.75ï¼Œå¦‚æœæš‚æ—¶æ— æ³•ç¡®å®šåˆå§‹å€¼å¤§å°ï¼Œè¯·è®¾ç½®ä¸º 16ï¼ˆå³é»˜è®¤å€¼ï¼‰ã€‚\u003cbr\u003e\nåä¾‹ï¼šHashMap éœ€è¦æ”¾ç½® 1024 ä¸ªå…ƒç´ ï¼Œç”±äºæ²¡æœ‰è®¾ç½®å®¹é‡åˆå§‹å¤§å°ï¼Œéšç€å…ƒç´ ä¸æ–­å¢åŠ ï¼Œå®¹é‡ 7 æ¬¡è¢«è¿«æ‰©å¤§ï¼Œresize éœ€è¦é‡å»º hash è¡¨ã€‚å½“æ”¾ç½®çš„é›†åˆå…ƒç´ ä¸ªæ•°è¾¾åƒä¸‡çº§åˆ«æ—¶ï¼Œä¸æ–­æ‰©å®¹ä¼šä¸¥é‡å½±å“æ€§èƒ½ã€‚\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eç±»ä¼¼çš„ï¼ŒGoogle å‡ºå“çš„ Guava åº“ä¹Ÿé’ˆå¯¹ HashMap çš„åˆå§‹åŒ–è¿›è¡Œäº†å°è£…ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static \u0026#x3C;K, V\u003e HashMap\u0026#x3C;K, V\u003e newHashMapWithExpectedSize(int expectedSize) {\n    return new HashMap(capacity(expectedSize));\n}\n\nstatic int capacity(int expectedSize) {\n    if (expectedSize \u0026#x3C; 3) {\n        CollectPreconditions.checkNonnegative(expectedSize, \"expectedSize\");\n        return expectedSize + 1;\n    } else {\n        return expectedSize \u0026#x3C; 1073741824 ? (int)((float)expectedSize / 0.75F + 1.0F) : 2147483647;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ— ä¸€ä¾‹å¤–ï¼Œå®ƒä»¬éƒ½ä½¿ç”¨ \u003ccode\u003e((float) expectedSize / loadFactor) + 1.0F\u003c/code\u003e ä½œä¸º HashMap çš„å…¥å‚ã€‚å› æ­¤åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œå¦‚æœçŸ¥é“éœ€è¦å­˜å‚¨çš„æ•°æ®é‡è¾ƒå¤§ï¼Œå¯ä»¥é‡‡ç”¨è¿™äº›æ–¹å¼è¿›è¡Œåˆå§‹åŒ–ï¼Œæé«˜ç³»ç»Ÿè¿è¡Œçš„æ•ˆç‡ã€‚\u003c/p\u003e\n\u003ch2\u003eå­˜æ•°æ®(put)\u003c/h2\u003e\n\u003cp\u003eåœ¨æ‰§è¡Œä¸€è¡Œ \u003ccode\u003emap.put(\"one\", \"\")\u003c/code\u003eä»£ç å¤§æ¦‚å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ\u003c/p\u003e\n\u003chr\u003e\n\u003col\u003e\n\u003cli\u003eæ ¹æ®å­—ç¬¦ä¸² \u003cem\u003eone\u003c/em\u003e çš„ \u003cem\u003ehashCode()\u003c/em\u003e åšä¸€æ¬¡ \u003cem\u003ehash\u003c/em\u003e è®¡ç®—\u003c/li\u003e\n\u003cli\u003eåˆ¤æ–­å“ˆå¸Œè¡¨æ˜¯å¦åˆå§‹åŒ–ã€‚å¦ï¼Œåˆ™è¿›è¡Œåˆå§‹åŒ– \u003ccode\u003eresize\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eæ ¹æ® \u003cem\u003ehash\u003c/em\u003e è®¡ç®— \u003cem\u003eone\u003c/em\u003e åœ¨å“ˆå¸Œè¡¨çš„å®é™…ä½ç½® \u003cem\u003eindex\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eåˆ¤æ–­æ‰€å¤„ä½ç½®æ˜¯å¦æœ‰æ•°æ® (å“ˆå¸Œç¢°æ’)\u003cul\u003e\n\u003cli\u003eæœ‰ä¸”ç­‰äº \u003cem\u003eone\u003c/em\u003e ï¼ŒæŠŠæ—§æ•°æ®è¦†ç›–æ‰\u003c/li\u003e\n\u003cli\u003eæœ‰ä¸”ä¸ç­‰äº \u003cem\u003eone\u003c/em\u003e\u003cul\u003e\n\u003cli\u003eåœ¨å½“å‰ä½ç½®ä»¥é“¾è¡¨æ–¹å¼è¿½åŠ ã€‚å¦‚æœé“¾è¡¨é•¿åº¦å¤§äºç­‰äº 7ï¼Œé“¾è¡¨é‡æ„ä¸ºçº¢é»‘æ ‘\u003cbr\u003e\nå¦‚æœè¿½åŠ è¿‡ç¨‹å‘ç°ç›¸åŒæ•°æ®  \u003cem\u003eone\u003c/em\u003eï¼Œè¦†ç›–æ—§æ•°æ®\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003eæ— ï¼Œç›´æ¥å­˜å…¥å“ˆå¸Œè¡¨\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003eå¦‚æœå½“å‰æ»¡è¶³ \u003ccode\u003eæ€»æ•°æ®é‡ \u003e load factor * current capacity\u003c/code\u003eï¼Œåˆ™æ•°æ®ç»“æ„é‡æ„ \u003ccode\u003eresize\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cp\u003eä»¥ä¸Šæµç¨‹å¯ç›´æ¥è¿›å…¥ \u003cstrong\u003ejava.util.HashMap#put\u003c/strong\u003e æ–¹æ³•ä¸€æ¢ç©¶ç«Ÿã€‚\u003c/p\u003e\n\u003ch2\u003eå“ˆå¸Œè¡¨çš„å®¹é‡(2^n)\u003c/h2\u003e\n\u003cp\u003eæ— è®ºæ˜¯å“ˆå¸Œè¡¨é»˜è®¤å¤§å°ã€æŒ‡å®šåˆå§‹å¤§å°ã€æ‰©å®¹å¤§å°ï¼Œç»“æœéƒ½å°†æ˜¯ \u003cstrong\u003e2çš„å¹‚\u003c/strong\u003eï¼ˆ2çš„næ¬¡æ–¹ï¼‰ã€‚\u003c/p\u003e\n\u003cp\u003eå¦‚æœæŒ‡å®š \u003ccode\u003einitialCapacity\u003c/code\u003eï¼Œé‚£ä¹ˆ \u003ccode\u003einitialCapacity\u003c/code\u003e å°±ä¼šè¢« \u003cstrong\u003ejava.util.HashMap#tableSizeFor\u003c/strong\u003e æ–¹æ³•å¤„ç†ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic HashMap(int initialCapacity)\n                          |\n                          |_______\n                                  |\nstatic final int tableSizeFor(int cap)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e/**\n* Returns a power of two size for the given target capacity.\n*/\nstatic final int tableSizeFor(int cap) {\n    int n = cap - 1;\n    n |= n \u003e\u003e\u003e 1;\n    n |= n \u003e\u003e\u003e 2;\n    n |= n \u003e\u003e\u003e 4;\n    n |= n \u003e\u003e\u003e 8;\n    n |= n \u003e\u003e\u003e 16;\n    return (n \u0026#x3C; 0) ? 1 : (n \u003e= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå‡è®¾æŒ‡å®š \u003ccode\u003einitialCapacity = 7\u003c/code\u003eï¼Œé‚£ä¹ˆæ ¹æ®ä»£ç é€»è¾‘å¯æ¨æ¼”å‡ºä»¥ä¸‹å†…å®¹ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-markdown\"\u003ecap = 7\nn = cap - 1 = 6 = 0 1 1 0\nn |= n \u003e\u003e\u003e 1;    0 1 1 0 | 0 0 1 1 = 0 1 1 1 = 7\nn |= n \u003e\u003e\u003e 2;    0 1 1 1 | 0 0 0 1 = 0 1 1 1 = 7\nn |= n \u003e\u003e\u003e 4;    0 1 1 1 | 0 0 0 0 = 0 1 1 1 = 7\nn |= n \u003e\u003e\u003e 8;    0 1 1 1 | 0 0 0 0 = 0 1 1 1 = 7\nn |= n \u003e\u003e\u003e 16;   0 1 1 1 | 0 0 0 0 = 0 1 1 1 = 7\nreturn n + 1     7 + 1 = 8 \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eæ‰€ä»¥è®¡ç®—å‡ºçš„å“ˆå¸Œè¡¨å®¹é‡æ˜¯ 8 = 2^3ï¼Œç„¶åå†æ ¹æ®\u003ccode\u003eload factor * current capacity\u003c/code\u003eè®¡ç®—å‡ºå½“å‰æœ‰æ•ˆå­˜å‚¨é‡ä¸º 6ï¼Œå¹¶å°† 6 èµ‹äºˆç»™ HashMap çš„å®ä¾‹å˜é‡ \u003ccode\u003ethreshold\u003c/code\u003e ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eint threshold;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eè€Œå½“å“ˆå¸Œè¡¨çš„æ•°æ®æ¡æ•°å¤§äº 6 å°†ä¼šå‘ç”Ÿ rehashã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eif (++size \u003e threshold)\n    resize();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå“ˆå¸Œè¡¨çš„æ‰©å®¹è®¡ç®—æ–¹å¼å¾ˆç®€å•ï¼š\u003c/p\u003e\n\u003cp\u003e \u003ccode\u003enewCap = oldCap \u0026#x3C;\u0026#x3C; 1\u003c/code\u003eï¼Œ\u003ccode\u003enewThr = oldThr \u0026#x3C;\u0026#x3C; 1\u003c/code\u003e\u003c/p\u003e\n\u003ch2\u003eè®¡ç®—ä½ç½®(ä¸‹æ ‡)\u003c/h2\u003e\n\u003cp\u003eåˆ†ä¸ºä¸¤æ­¥ï¼Œé¦–å…ˆè®¡ç®—ä¸€æ¬¡ hashï¼Œåˆ©ç”¨ key çš„ hashcode é«˜åå…­ä½å’Œä½åå…­ä½è¿›è¡Œå¼‚æˆ–è¿ç®—ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003estatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eç„¶åæ˜¯ä¸‹æ ‡çš„è®¡ç®—ï¼Œn ä»£è¡¨å“ˆå¸Œè¡¨å®¹é‡ï¼Œå°†å‡†å¤‡å¥½çš„ hash å†æ¬¡è¿›è¡Œ \u003ccode\u003e\u0026#x26;\u003c/code\u003e è¿ç®—ï¼Œ n-1 é¿å…æ•°ç»„è¶Šç•Œï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ei = (n - 1) \u0026#x26; hash\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå‡è®¾å“ˆå¸Œè¡¨å®¹é‡ä¸º 8ï¼Œå¹¶ä¸”å­˜å…¥ä¸€æ¡æ•°æ®ï¼š \u003ccode\u003emap.put(\"abcabcabc\", \"\")\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eh = key.hashCode(): 0001 0010 0100 0011 1011 0011 1010 0010 // \"abcabcabc\".hashCode();\n                                      xor\nh \u003e\u003e\u003e 16:           0000 0000 0000 0000 0001 0010 0100 0011\n                                      â†“â†“â†“\nhash = h ^ h\u003e\u003e\u003e16:  0001 0010 0100 0011 1010 0001 1110 0001\n                                       \u0026#x26;\nn - 1:              0000 0000 0000 0000 0000 0000 0000 0111\n                                      â†“â†“â†“\n(n - 1) \u0026#x26; hash:     0000 0000 0000 0000 0000 0000 0000 0001 // index = 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå› æ­¤è®¡ç®—å‡º â€œabcabcabcâ€ è¿™ä¸ª key åœ¨å“ˆå¸Œè¡¨çš„ä½ç½®(ä¸‹æ ‡)æ˜¯ 1 ã€‚\u003c/p\u003e\n\u003cp\u003eå…³äº hash å‡½æ•°çš„è®¾è®¡ï¼Œä»£ç æ³¨é‡Šçš„è¯´æ³•æ˜¯ï¼š\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e  Computes key.hashCode() and spreads (XORs) higher bits of hash to lower.  Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.)  So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don't benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eæ³¨é‡Šä¸­è¯´åˆ°ï¼Œå¤§å¤šæ•°çš„ hashCode çš„åˆ†å¸ƒå·²ç»éå¸¸åˆç†äº†ï¼Œå¦‚æœè¿˜å‘ç”Ÿå†²çªå°±ä½¿ç”¨é“¾è¡¨æˆ–è€…æ ‘ç»“æ„è§£å†³ï¼Œå› æ­¤è®¾è®¡è€…ä½¿ç”¨æœ€èŠ‚çœç³»ç»Ÿæ€§èƒ½å¼€é”€çš„ç§»ä½ä»¥åŠå¼‚æˆ–è¿ç®—æ¥é¿å…æ›´å¤šçš„å†²çªã€‚\u003c/p\u003e\n\u003cp\u003eä½¿ç”¨ hash å‡½æ•°ï¼Œæ˜¯å› ä¸ºè¦è€ƒè™‘åˆ°ï¼Œå¦‚æœä½¿ç”¨çš„ hashCode ä»…åœ¨é«˜ä½ä¸åŒï¼Œè€Œä½ä½ç›¸åŒï¼Œé‚£ä¹ˆåœ¨æç«¯æƒ…å†µä¸‹å‘ç”Ÿå†²çªæ¦‚ç‡å°†å¢å¤§ã€‚\u003c/p\u003e\n\u003cp\u003eä¾‹å¦‚ï¼š\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ehashCode 1:         1100 0011 1000 0011 1000 1010 0001 0000\nhashCode 2:         0100 1011 0100 1100 1111 0110 1100 0000\nhashCode 3:         0000 0001 1001 1001 0110 1011 1110 0000\n                                       \u0026#x26;\nn - 1:              0000 0000 0000 0000 0000 0000 0000 0111\n                                      â†“â†“â†“\n(n - 1) \u0026#x26; hashCode: 0000 0000 0000 0000 0000 0000 0000 0111 // Index is always the same: 7\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœä¸‰ä¸ª hashCode çš„é«˜ä½ä¸åŒï¼Œè€Œä½ 3 ä½å®Œå…¨ç›¸åŒ(å…¨ä¸º 0)ï¼Œé‚£  \u003ccode\u003e(n -1) \u0026#x26; hashCode\u003c/code\u003e è¿ç®—çš„ç»“æœéƒ½ç›¸åŒ (7)ï¼Œè¿™ç§æƒ…å†µæ‰€æœ‰çš„æ•°æ®éƒ½ä»¥é“¾è¡¨æˆ–è€…æ ‘ç»“æ„å½¢å¼å­˜åœ¨åŒä¸€ä½ç½® (7)ã€‚å¦‚æœå‘ç”Ÿæ›´å¤šå†²çªï¼Œæ—¶é—´å¤æ‚åº¦ä» O(1) å˜ä¸º O(n) æˆ–è€… O(log n)ï¼Œæ€§èƒ½å°±ä¼šæœ‰æ‰€é™ä½ã€‚\u003c/p\u003e\n\u003cp\u003eä½¿ç”¨ XOR çš„åŸå› ï¼Œæ˜¯å› ä¸ºè¿™æ ·çš„è¿ç®—å¯ä½¿å¾— 1 å’Œ 0 å…·æœ‰ 50% / 50% çš„åˆ†å¸ƒï¼Œç›¸æ¯”äº \u003ccode\u003e\u0026#x26;\u003c/code\u003e å’Œ \u003ccode\u003e|\u003c/code\u003e çš„ 25/75 å’Œ 75/25 æ›´åŠ å¹³å‡ã€ç¨³å®šã€‚\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eXOR\u003c/th\u003e\n\u003cth\u003e1\u003c/th\u003e\n\u003cth\u003e0\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e1\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e0\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e1 å’Œ 0 æ•°é‡å„å æ€»æ•°ä¸€åŠã€‚\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u0026#x26;\u003c/th\u003e\n\u003cth\u003e1\u003c/th\u003e\n\u003cth\u003e0\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e1\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e0\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e1 å’Œ 0 æ•°é‡å„å æ€»æ•° 25% å’Œ 75%ã€‚\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e|\u003c/th\u003e\n\u003cth\u003e1\u003c/th\u003e\n\u003cth\u003e0\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e1\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003e0\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e1 å’Œ 0 æ•°é‡å„å æ€»æ•° 75% å’Œ 25%ã€‚\u003c/p\u003e\n\u003ch2\u003eæ‰©å®¹(resize)\u003c/h2\u003e\n\u003cp\u003eå“ˆå¸Œè¡¨çš„åˆå§‹åŒ–ä¸æ‰©å®¹éƒ½ä½¿ç”¨åŒä¸€å¥—é€»è¾‘ï¼Œå³ \u003cstrong\u003ejava.util.HashMap#resize\u003c/strong\u003e æ–¹æ³•ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003efinal Node\u0026#x3C;K,V\u003e[] resize()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003eInitializes or doubles table size.  If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eå¤§è‡´æ„æ€å°±æ˜¯è¯´ï¼Œå½“è¶…è¿‡é™åˆ¶çš„æ—¶å€™ä¼š resizeï¼Œç„¶è€Œåˆå› ä¸ºæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯2æ¬¡å¹‚çš„æ‰©å±•(æŒ‡é•¿åº¦æ‰©ä¸ºåŸæ¥2å€)ï¼Œæ‰€ä»¥ï¼Œå…ƒç´ çš„ä½ç½®è¦ä¹ˆæ˜¯åœ¨åŸä½ç½®ï¼Œè¦ä¹ˆæ˜¯åœ¨åŸä½ç½®å†ç§»åŠ¨2æ¬¡å¹‚çš„ä½ç½®ã€‚\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://resource.1024kb.top/image/code-sample/hashmap-resize.png\" alt=\"git-rebase.gif\"\u003e\u003c/p\u003e\n\u003cp\u003eè§‚å¯Ÿä¸Šå›¾æ‰©å®¹å(8 -\u003e 16)çš„æ•°æ®åˆ†å¸ƒï¼Œè¦ä¹ˆæ˜¯æ”¹å˜äº†ç´¢å¼•ï¼Œè¦ä¹ˆæ˜¯ä¸å˜ï¼Œæ”¹å˜çš„å°±æ˜¯ç§»åŠ¨2æ¬¡å¹‚çš„ä½ç½®(+8)ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e5 + 8 = 13\n    4 = 4\n0 + 8 = 8\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå†æ¬¡æ‰©å®¹äº¦æ˜¯å¦‚æ­¤ï¼Œå¦‚ 16 -\u003e 32 ï¼Œé‚£ä¹ˆæ”¹å˜çš„ä¹Ÿæ˜¯ç§»åŠ¨2æ¬¡å¹‚çš„ä½ç½®(+16)ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e13 + 16 = 29\n4  + 16 = 20\n8  + 16 = 24\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eå¯¹äºæ˜¯å¦éœ€è¦æ”¹å˜ç´¢å¼•ï¼Œåªéœ€è¦çœ‹çœ‹åŸæ¥çš„ hash å€¼æ–°å¢çš„é‚£ä¸ª bit æ˜¯ 1 è¿˜æ˜¯ 0 å°±å¥½äº†ï¼Œæ˜¯ 0 åˆ™æ— éœ€æ”¹å˜ä½ç½®ã€‚ä¾‹å¦‚ä¸Šå›¾çš„ hash2ï¼Œæ‰©å®¹åç”± \u003ccode\u003e100\u003c/code\u003e å˜ä¸º \u003ccode\u003e0100\u003c/code\u003eï¼Œå¤šå‡ºçš„ä¸€ä½æ•°æ˜¯ 0ï¼Œé‚£ä¹ˆ 0 å’Œå…¶å®ƒæ•°å­—è¿›è¡Œä¸è¿ç®—éƒ½æ˜¯ 0ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ehash2:   100\n          \u0026#x26;\nn = 8:   111 \n          â†“\n         100 = 4\n--------------------\nhash2:  0100\n          \u0026#x26;\nn = 16: 1111\n          â†“\n        0100 = 4\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eå–æ•°æ®(get)\u003c/h2\u003e\n\u003cp\u003eåœ¨ç†è§£ä»¥ä¸Šé€»è¾‘ä¹‹åï¼Œget å°±å¾ˆç®€å•äº†ã€‚å¤§è‡´æ€è·¯å¦‚ä¸‹ï¼š\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eæ ¹æ® key çš„ hashCode è¿›è¡Œä¸€æ¬¡ hash\u003c/li\u003e\n\u003cli\u003eåˆ©ç”¨ \u003ccode\u003e(n - 1) \u0026#x26; hash\u003c/code\u003e è®¡ç®—å‡ºå®é™…ä½ç½®(ç´¢å¼•)\u003c/li\u003e\n\u003cli\u003eå¦‚æœæ ¹æ®ç´¢å¼•ç›´æ¥åŒ¹é…åˆ°ï¼Œç›´æ¥è¿”å›ï¼Œ O(1)\u003c/li\u003e\n\u003cli\u003eå¦‚æœæ ¹æ®ç´¢å¼•æœªèƒ½åŒ¹é…åˆ°\u003cul\u003e\n\u003cli\u003eè‹¥ä¸ºæ ‘ï¼Œåˆ™ä½¿ç”¨æŸ¥è¯¢æ ‘çš„æ“ä½œï¼ŒO(logn)\u003c/li\u003e\n\u003cli\u003eè‹¥ä¸ºé“¾è¡¨ï¼Œåˆ™å¾ªç¯é“¾è¡¨æŸ¥æ‰¾ï¼ŒO(n)\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eæµ‹è¯•\u003c/h2\u003e\n\u003cp\u003eåˆ©ç”¨ benchmark æµ‹è¯•å·¥å…·æ¥æµ‹è¯• HashMapï¼Œåœ¨åˆå§‹åŒ–æŒ‡å®šå®¹é‡ä¸ä½¿ç”¨é»˜è®¤æ„é€ å‡½æ•°çš„æ€§èƒ½åŒºåˆ«ã€‚\u003c/p\u003e\n\u003cp\u003eæµ‹è¯•åˆ†ä¸º 5 ä¸ªç­‰çº§ï¼š\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eæ·»åŠ ä¸åŒçš„æ•°æ®ç›´åˆ°æ»¡è¶³ 16 æ¡\u003c/li\u003e\n\u003cli\u003eæ·»åŠ ä¸åŒçš„æ•°æ®ç›´åˆ°æ»¡è¶³ 100 æ¡\u003c/li\u003e\n\u003cli\u003eæ·»åŠ ä¸åŒçš„æ•°æ®ç›´åˆ°æ»¡è¶³ 1000 æ¡\u003c/li\u003e\n\u003cli\u003eæ·»åŠ ä¸åŒçš„æ•°æ®ç›´åˆ°æ»¡è¶³ 10000 æ¡\u003c/li\u003e\n\u003cli\u003eæ·»åŠ ä¸åŒçš„æ•°æ®ç›´åˆ°æ»¡è¶³ 100000 æ¡\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eä½¿ç”¨é»˜è®¤æ„é€ å‡½æ•°ï¼š\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eBenchmark\u003c/th\u003e\n\u003cth\u003eMode\u003c/th\u003e\n\u003cth\u003eCnt\u003c/th\u003e\n\u003cth\u003eScore\u003c/th\u003e\n\u003cth\u003eError\u003c/th\u003e\n\u003cth\u003eUnits\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eMapBenchmark.measure_level1\u003c/td\u003e\n\u003ctd\u003ethrpt\u003c/td\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e141991260.547 Â±  419002.953\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003eops/s\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMapBenchmark.measure_level2\u003c/td\u003e\n\u003ctd\u003ethrpt\u003c/td\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e66501311.793 Â± 5285311.107\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003eops/s\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMapBenchmark.measure_level3\u003c/td\u003e\n\u003ctd\u003ethrpt\u003c/td\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e70077920.597 Â± 6574269.856\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003eops/s\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMapBenchmark.measure_level4\u003c/td\u003e\n\u003ctd\u003ethrpt\u003c/td\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e58270016.113 Â± 3106384.470\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003eops/s\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMapBenchmark.measure_level5\u003c/td\u003e\n\u003ctd\u003ethrpt\u003c/td\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e25518813.878 Â± 1097213.863\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003eops/s\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eä½¿ç”¨åˆå§‹åŒ–å®¹é‡çš„æ„é€ å‡½æ•°ï¼Œå¹¶ä¸”è€ƒè™‘å®é™…æ•°æ®é‡ä¼ å…¥åˆç†çš„å‚æ•°ï¼š\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eBenchmark\u003c/th\u003e\n\u003cth\u003eMode\u003c/th\u003e\n\u003cth\u003eCnt\u003c/th\u003e\n\u003cth\u003eScore\u003c/th\u003e\n\u003cth\u003eError\u003c/th\u003e\n\u003cth\u003eUnits\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eMapBenchmark.measure_level1\u003c/td\u003e\n\u003ctd\u003ethrpt\u003c/td\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e122338131.327 Â±  9689798.828\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003eops/s\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMapBenchmark.measure_level2\u003c/td\u003e\n\u003ctd\u003ethrpt\u003c/td\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e102039334.216 Â±  2403155.914\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003eops/s\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMapBenchmark.measure_level3\u003c/td\u003e\n\u003ctd\u003ethrpt\u003c/td\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e96752178.779 Â±  4839327.658\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003eops/s\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMapBenchmark.measure_level4\u003c/td\u003e\n\u003ctd\u003ethrpt\u003c/td\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e88239132.356 Â±  9597356.077\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003eops/s\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMapBenchmark.measure_level5\u003c/td\u003e\n\u003ctd\u003ethrpt\u003c/td\u003e\n\u003ctd\u003e5\u003c/td\u003e\n\u003ctd\u003e55940080.977 Â± 13094145.548\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003eops/s\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eå…³æ³¨ Score çš„ç»“æœï¼Œå®ƒä»¬éƒ½æ˜¯ xxx Â± xxxï¼ŒUnits ä»£è¡¨å•ä½æ¯ç§’å¤šå°‘æ¬¡æ“ä½œã€‚\u003c/p\u003e\n\u003cp\u003eå¯ä»¥çœ‹åˆ°æ— è®ºå“ªç§åˆå§‹åŒ–æ“ä½œï¼Œéšç€æ•°æ®é‡å¢å¤§ï¼Œæ¯ç§’æ“ä½œæ¬¡æ•°éƒ½éšä¹‹é™ä½ã€‚è€ŒåŒæ ·æ¡ä»¶ä¸‹ï¼Œä½¿ç”¨\u003cstrong\u003eåˆå§‹åŒ–å®¹é‡çš„æ„é€ å‡½æ•°\u003c/strong\u003eç›¸æ¯”ä½¿ç”¨\u003cstrong\u003eé»˜è®¤æ„é€ å‡½æ•°\u003c/strong\u003eï¼Œå‰è€…æ€§èƒ½æ›´ä½³ã€‚\u003c/p\u003e\n\u003ch1\u003eé™„å½•\u003c/h1\u003e\n\u003cp\u003e benchmark æµ‹è¯•ä»£ç ã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@State(Scope.Thread)\npublic class MapBenchmark {\n\n  String[] resource;\n\n  @Setup()\n  public void prepare() {\n      resource = new String[100000];\n      for (int i = 0; i \u0026#x3C; resource.length; i++) {\n          resource[i] = String.valueOf(i);\n      }\n  }\n\n  private Map\u0026#x3C;String, String\u003e reps(int reps) {\n      // Map\u0026#x3C;String, String\u003e map = new HashMap\u0026#x3C;\u003e((int) ((float) reps / 0.75F + 1.0F)); // ä½¿ç”¨åˆå§‹åŒ–å®¹é‡çš„æ„é€ å‡½æ•°\n      Map\u0026#x3C;String, String\u003e map = new HashMap\u0026#x3C;\u003e(); // ä½¿ç”¨é»˜è®¤æ„é€ å‡½æ•°\n\n      for (int i = 0; i \u0026#x3C; reps; i++) {\n          String test = resource[i];\n          map.put(test, test);\n      }\n      return map;\n  }\n\n  @Benchmark\n  @OperationsPerInvocation(10)\n  public Map\u0026#x3C;String, String\u003e measure_level1() {\n      return reps(10);\n  }\n\n  @Benchmark\n  @OperationsPerInvocation(100)\n  public Map\u0026#x3C;String, String\u003e measure_level2() {\n      return reps(100);\n  }\n\n  @Benchmark\n  @OperationsPerInvocation(1000)\n  public Map\u0026#x3C;String, String\u003e measure_level3() {\n      return reps(1000);\n  }\n\n  @Benchmark\n  @OperationsPerInvocation(10000)\n  public Map\u0026#x3C;String, String\u003e measure_level4() {\n      return reps(10_000);\n  }\n\n  @Benchmark\n  @OperationsPerInvocation(100000)\n  public Map\u0026#x3C;String, String\u003e measure_level5() {\n      return reps(100_000);\n  }\n\n  public static void main(String[] args) throws RunnerException {\n      Options opt = new OptionsBuilder()\n              .include(MapBenchmark.class.getSimpleName())\n              .forks(1)\n              .build();\n      new Runner(opt).run();\n  }\n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eä½¿ç”¨é»˜è®¤æ„é€ å‡½æ•°çš„æµ‹è¯•ç»“æœã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e# JMH version: 1.23\n# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11\n# VM invoker: C:\\Program Files\\Java\\jdk1.8.0_221\\jre\\bin\\java.exe\n# VM options: -javaagent:E:\\app\\IntelliJ IDEA 2019.1.4\\lib\\idea_rt.jar=53301:E:\\app\\IntelliJ IDEA 2019.1.4\\bin -Dfile.encoding=UTF-8\n# Warmup: 5 iterations, 10 s each\n# Measurement: 5 iterations, 10 s each\n# Timeout: 10 min per iteration\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: tester.MapBenchmark.measure_level1\n\n# Run progress: 0.00% complete, ETA 00:08:20\n# Fork: 1 of 1\n# Warmup Iteration   1: 127001625.901 ops/s\n# Warmup Iteration   2: 141822524.390 ops/s\n# Warmup Iteration   3: 133428241.333 ops/s\n# Warmup Iteration   4: 132244469.411 ops/s\n# Warmup Iteration   5: 138276778.513 ops/s\nIteration   1: 141895511.199 ops/s\nIteration   2: 141923059.081 ops/s\nIteration   3: 142158823.597 ops/s\nIteration   4: 141937212.493 ops/s\nIteration   5: 142041696.363 ops/s\n\n\nResult \"tester.MapBenchmark.measure_level1\":\n  141991260.547 Â±(99.9%) 419002.953 ops/s [Average]\n  (min, avg, max) = (141895511.199, 141991260.547, 142158823.597), stdev = 108813.736\n  CI (99.9%): [141572257.593, 142410263.500] (assumes normal distribution)\n\n\n# JMH version: 1.23\n# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11\n# VM invoker: C:\\Program Files\\Java\\jdk1.8.0_221\\jre\\bin\\java.exe\n# VM options: -javaagent:E:\\app\\IntelliJ IDEA 2019.1.4\\lib\\idea_rt.jar=53301:E:\\app\\IntelliJ IDEA 2019.1.4\\bin -Dfile.encoding=UTF-8\n# Warmup: 5 iterations, 10 s each\n# Measurement: 5 iterations, 10 s each\n# Timeout: 10 min per iteration\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: tester.MapBenchmark.measure_level2\n\n# Run progress: 20.00% complete, ETA 00:06:43\n# Fork: 1 of 1\n# Warmup Iteration   1: 66265103.610 ops/s\n# Warmup Iteration   2: 66389800.461 ops/s\n# Warmup Iteration   3: 67855747.609 ops/s\n# Warmup Iteration   4: 67289955.476 ops/s\n# Warmup Iteration   5: 67750553.602 ops/s\nIteration   1: 67298893.171 ops/s\nIteration   2: 66615628.545 ops/s\nIteration   3: 64314592.829 ops/s\nIteration   4: 66334869.364 ops/s\nIteration   5: 67942575.053 ops/s\n\n\nResult \"tester.MapBenchmark.measure_level2\":\n  66501311.793 Â±(99.9%) 5285311.107 ops/s [Average]\n  (min, avg, max) = (64314592.829, 66501311.793, 67942575.053), stdev = 1372578.510\n  CI (99.9%): [61216000.685, 71786622.900] (assumes normal distribution)\n\n\n# JMH version: 1.23\n# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11\n# VM invoker: C:\\Program Files\\Java\\jdk1.8.0_221\\jre\\bin\\java.exe\n# VM options: -javaagent:E:\\app\\IntelliJ IDEA 2019.1.4\\lib\\idea_rt.jar=53301:E:\\app\\IntelliJ IDEA 2019.1.4\\bin -Dfile.encoding=UTF-8\n# Warmup: 5 iterations, 10 s each\n# Measurement: 5 iterations, 10 s each\n# Timeout: 10 min per iteration\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: tester.MapBenchmark.measure_level3\n\n# Run progress: 40.00% complete, ETA 00:05:02\n# Fork: 1 of 1\n# Warmup Iteration   1: 67605636.507 ops/s\n# Warmup Iteration   2: 69621052.760 ops/s\n# Warmup Iteration   3: 71010248.192 ops/s\n# Warmup Iteration   4: 69532881.868 ops/s\n# Warmup Iteration   5: 71013446.760 ops/s\nIteration   1: 70574046.109 ops/s\nIteration   2: 70965533.458 ops/s\nIteration   3: 71067189.031 ops/s\nIteration   4: 70739591.373 ops/s\nIteration   5: 67043243.012 ops/s\n\n\nResult \"tester.MapBenchmark.measure_level3\":\n  70077920.597 Â±(99.9%) 6574269.856 ops/s [Average]\n  (min, avg, max) = (67043243.012, 70077920.597, 71067189.031), stdev = 1707317.004\n  CI (99.9%): [63503650.740, 76652190.453] (assumes normal distribution)\n\n\n# JMH version: 1.23\n# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11\n# VM invoker: C:\\Program Files\\Java\\jdk1.8.0_221\\jre\\bin\\java.exe\n# VM options: -javaagent:E:\\app\\IntelliJ IDEA 2019.1.4\\lib\\idea_rt.jar=53301:E:\\app\\IntelliJ IDEA 2019.1.4\\bin -Dfile.encoding=UTF-8\n# Warmup: 5 iterations, 10 s each\n# Measurement: 5 iterations, 10 s each\n# Timeout: 10 min per iteration\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: tester.MapBenchmark.measure_level4\n\n# Run progress: 60.00% complete, ETA 00:03:21\n# Fork: 1 of 1\n# Warmup Iteration   1: 58376736.170 ops/s\n# Warmup Iteration   2: 56309258.446 ops/s\n# Warmup Iteration   3: 58577905.930 ops/s\n# Warmup Iteration   4: 58987213.188 ops/s\n# Warmup Iteration   5: 56652677.235 ops/s\nIteration   1: 56883247.928 ops/s\nIteration   2: 58521062.413 ops/s\nIteration   3: 58301230.510 ops/s\nIteration   4: 58767115.865 ops/s\nIteration   5: 58877423.848 ops/s\n\n\nResult \"tester.MapBenchmark.measure_level4\":\n  58270016.113 Â±(99.9%) 3106384.470 ops/s [Average]\n  (min, avg, max) = (56883247.928, 58270016.113, 58877423.848), stdev = 806718.182\n  CI (99.9%): [55163631.643, 61376400.583] (assumes normal distribution)\n\n\n# JMH version: 1.23\n# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11\n# VM invoker: C:\\Program Files\\Java\\jdk1.8.0_221\\jre\\bin\\java.exe\n# VM options: -javaagent:E:\\app\\IntelliJ IDEA 2019.1.4\\lib\\idea_rt.jar=53301:E:\\app\\IntelliJ IDEA 2019.1.4\\bin -Dfile.encoding=UTF-8\n# Warmup: 5 iterations, 10 s each\n# Measurement: 5 iterations, 10 s each\n# Timeout: 10 min per iteration\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: tester.MapBenchmark.measure_level5\n\n# Run progress: 80.00% complete, ETA 00:01:40\n# Fork: 1 of 1\n# Warmup Iteration   1: 24666505.202 ops/s\n# Warmup Iteration   2: 25541321.825 ops/s\n# Warmup Iteration   3: 25787825.310 ops/s\n# Warmup Iteration   4: 25812122.914 ops/s\n# Warmup Iteration   5: 25673018.223 ops/s\nIteration   1: 25745027.348 ops/s\nIteration   2: 25655260.447 ops/s\nIteration   3: 25747293.453 ops/s\nIteration   4: 25341679.313 ops/s\nIteration   5: 25104808.828 ops/s\n\n\nResult \"tester.MapBenchmark.measure_level5\":\n  25518813.878 Â±(99.9%) 1097213.863 ops/s [Average]\n  (min, avg, max) = (25104808.828, 25518813.878, 25747293.453), stdev = 284942.956\n  CI (99.9%): [24421600.015, 26616027.741] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:08:23\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark                     Mode  Cnt          Score         Error  Units\nMapBenchmark.measure_level1  thrpt    5  141991260.547 Â±  419002.953  ops/s\nMapBenchmark.measure_level2  thrpt    5   66501311.793 Â± 5285311.107  ops/s\nMapBenchmark.measure_level3  thrpt    5   70077920.597 Â± 6574269.856  ops/s\nMapBenchmark.measure_level4  thrpt    5   58270016.113 Â± 3106384.470  ops/s\nMapBenchmark.measure_level5  thrpt    5   25518813.878 Â± 1097213.863  ops/s\n\nProcess finished with exit code 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eä½¿ç”¨åˆå§‹åŒ–æ„é€ å‡½æ•°çš„æµ‹è¯•ç»“æœã€‚\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e# JMH version: 1.23\n# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11\n# VM invoker: C:\\Program Files\\Java\\jdk1.8.0_221\\jre\\bin\\java.exe\n# VM options: -javaagent:E:\\app\\IntelliJ IDEA 2019.1.4\\lib\\idea_rt.jar=53688:E:\\app\\IntelliJ IDEA 2019.1.4\\bin -Dfile.encoding=UTF-8\n# Warmup: 5 iterations, 10 s each\n# Measurement: 5 iterations, 10 s each\n# Timeout: 10 min per iteration\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: tester.MapBenchmark.measure_level1\n\n# Run progress: 0.00% complete, ETA 00:08:20\n# Fork: 1 of 1\n# Warmup Iteration   1: 118482946.186 ops/s\n# Warmup Iteration   2: 112336132.574 ops/s\n# Warmup Iteration   3: 118383971.447 ops/s\n# Warmup Iteration   4: 116669575.125 ops/s\n# Warmup Iteration   5: 119473270.826 ops/s\nIteration   1: 121741335.641 ops/s\nIteration   2: 124303130.157 ops/s\nIteration   3: 124904353.757 ops/s\nIteration   4: 118528835.278 ops/s\nIteration   5: 122213001.803 ops/s\n\n\nResult \"tester.MapBenchmark.measure_level1\":\n  122338131.327 Â±(99.9%) 9689798.828 ops/s [Average]\n  (min, avg, max) = (118528835.278, 122338131.327, 124904353.757), stdev = 2516409.984\n  CI (99.9%): [112648332.499, 132027930.155] (assumes normal distribution)\n\n\n# JMH version: 1.23\n# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11\n# VM invoker: C:\\Program Files\\Java\\jdk1.8.0_221\\jre\\bin\\java.exe\n# VM options: -javaagent:E:\\app\\IntelliJ IDEA 2019.1.4\\lib\\idea_rt.jar=53688:E:\\app\\IntelliJ IDEA 2019.1.4\\bin -Dfile.encoding=UTF-8\n# Warmup: 5 iterations, 10 s each\n# Measurement: 5 iterations, 10 s each\n# Timeout: 10 min per iteration\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: tester.MapBenchmark.measure_level2\n\n# Run progress: 20.00% complete, ETA 00:06:43\n# Fork: 1 of 1\n# Warmup Iteration   1: 93315434.143 ops/s\n# Warmup Iteration   2: 92983341.778 ops/s\n# Warmup Iteration   3: 97101517.219 ops/s\n# Warmup Iteration   4: 92564247.846 ops/s\n# Warmup Iteration   5: 100285038.019 ops/s\nIteration   1: 102162049.729 ops/s\nIteration   2: 102379826.993 ops/s\nIteration   3: 102475922.945 ops/s\nIteration   4: 100944632.787 ops/s\nIteration   5: 102234238.627 ops/s\n\n\nResult \"tester.MapBenchmark.measure_level2\":\n  102039334.216 Â±(99.9%) 2403155.914 ops/s [Average]\n  (min, avg, max) = (100944632.787, 102039334.216, 102475922.945), stdev = 624091.959\n  CI (99.9%): [99636178.302, 104442490.130] (assumes normal distribution)\n\n\n# JMH version: 1.23\n# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11\n# VM invoker: C:\\Program Files\\Java\\jdk1.8.0_221\\jre\\bin\\java.exe\n# VM options: -javaagent:E:\\app\\IntelliJ IDEA 2019.1.4\\lib\\idea_rt.jar=53688:E:\\app\\IntelliJ IDEA 2019.1.4\\bin -Dfile.encoding=UTF-8\n# Warmup: 5 iterations, 10 s each\n# Measurement: 5 iterations, 10 s each\n# Timeout: 10 min per iteration\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: tester.MapBenchmark.measure_level3\n\n# Run progress: 40.00% complete, ETA 00:05:02\n# Fork: 1 of 1\n# Warmup Iteration   1: 97822881.423 ops/s\n# Warmup Iteration   2: 95718868.583 ops/s\n# Warmup Iteration   3: 97607085.636 ops/s\n# Warmup Iteration   4: 95961881.083 ops/s\n# Warmup Iteration   5: 96181959.004 ops/s\nIteration   1: 97486071.647 ops/s\nIteration   2: 97317494.401 ops/s\nIteration   3: 97341695.379 ops/s\nIteration   4: 97097857.201 ops/s\nIteration   5: 94517775.269 ops/s\n\n\nResult \"tester.MapBenchmark.measure_level3\":\n  96752178.779 Â±(99.9%) 4839327.658 ops/s [Average]\n  (min, avg, max) = (94517775.269, 96752178.779, 97486071.647), stdev = 1256758.025\n  CI (99.9%): [91912851.122, 101591506.437] (assumes normal distribution)\n\n\n# JMH version: 1.23\n# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11\n# VM invoker: C:\\Program Files\\Java\\jdk1.8.0_221\\jre\\bin\\java.exe\n# VM options: -javaagent:E:\\app\\IntelliJ IDEA 2019.1.4\\lib\\idea_rt.jar=53688:E:\\app\\IntelliJ IDEA 2019.1.4\\bin -Dfile.encoding=UTF-8\n# Warmup: 5 iterations, 10 s each\n# Measurement: 5 iterations, 10 s each\n# Timeout: 10 min per iteration\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: tester.MapBenchmark.measure_level4\n\n# Run progress: 60.00% complete, ETA 00:03:21\n# Fork: 1 of 1\n# Warmup Iteration   1: 92047944.166 ops/s\n# Warmup Iteration   2: 89678443.566 ops/s\n# Warmup Iteration   3: 89812773.142 ops/s\n# Warmup Iteration   4: 88930887.557 ops/s\n# Warmup Iteration   5: 85792676.395 ops/s\nIteration   1: 89347289.220 ops/s\nIteration   2: 89191963.589 ops/s\nIteration   3: 83800965.269 ops/s\nIteration   4: 89119847.919 ops/s\nIteration   5: 89735595.781 ops/s\n\n\nResult \"tester.MapBenchmark.measure_level4\":\n  88239132.356 Â±(99.9%) 9597356.077 ops/s [Average]\n  (min, avg, max) = (83800965.269, 88239132.356, 89735595.781), stdev = 2492402.896\n  CI (99.9%): [78641776.279, 97836488.433] (assumes normal distribution)\n\n\n# JMH version: 1.23\n# VM version: JDK 1.8.0_221, Java HotSpot(TM) 64-Bit Server VM, 25.221-b11\n# VM invoker: C:\\Program Files\\Java\\jdk1.8.0_221\\jre\\bin\\java.exe\n# VM options: -javaagent:E:\\app\\IntelliJ IDEA 2019.1.4\\lib\\idea_rt.jar=53688:E:\\app\\IntelliJ IDEA 2019.1.4\\bin -Dfile.encoding=UTF-8\n# Warmup: 5 iterations, 10 s each\n# Measurement: 5 iterations, 10 s each\n# Timeout: 10 min per iteration\n# Threads: 1 thread, will synchronize iterations\n# Benchmark mode: Throughput, ops/time\n# Benchmark: tester.MapBenchmark.measure_level5\n\n# Run progress: 80.00% complete, ETA 00:01:40\n# Fork: 1 of 1\n# Warmup Iteration   1: 54077395.641 ops/s\n# Warmup Iteration   2: 59732722.907 ops/s\n# Warmup Iteration   3: 53583150.778 ops/s\n# Warmup Iteration   4: 59899100.161 ops/s\n# Warmup Iteration   5: 60709074.795 ops/s\nIteration   1: 60754432.284 ops/s\nIteration   2: 51357719.856 ops/s\nIteration   3: 55849596.896 ops/s\nIteration   4: 54854535.391 ops/s\nIteration   5: 56884120.457 ops/s\n\n\nResult \"tester.MapBenchmark.measure_level5\":\n  55940080.977 Â±(99.9%) 13094145.548 ops/s [Average]\n  (min, avg, max) = (51357719.856, 55940080.977, 60754432.284), stdev = 3400508.017\n  CI (99.9%): [42845935.429, 69034226.525] (assumes normal distribution)\n\n\n# Run complete. Total time: 00:08:23\n\nREMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on\nwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial\nexperiments, perform baseline and negative tests that provide experimental control, make sure\nthe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.\nDo not assume the numbers tell you what you want them to tell.\n\nBenchmark                     Mode  Cnt          Score          Error  Units\nMapBenchmark.measure_level1  thrpt    5  122338131.327 Â±  9689798.828  ops/s\nMapBenchmark.measure_level2  thrpt    5  102039334.216 Â±  2403155.914  ops/s\nMapBenchmark.measure_level3  thrpt    5   96752178.779 Â±  4839327.658  ops/s\nMapBenchmark.measure_level4  thrpt    5   88239132.356 Â±  9597356.077  ops/s\nMapBenchmark.measure_level5  thrpt    5   55940080.977 Â± 13094145.548  ops/s\n\nProcess finished with exit code 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eå‚è€ƒèµ„æ–™\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eOracle, Class HashMap, \u003cem\u003eOracle Java Documentation\u003c/em\u003e. \u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html\"\u003eğŸ“„\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eYikun, Java-HashMapå·¥ä½œåŸç†åŠå®ç°, \u003cem\u003eYikunâ€™s\u003c/em\u003e Blog, 2015. \u003ca href=\"https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/\"\u003eğŸ“„\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eç¾å›¢, Java 8ç³»åˆ—ä¹‹é‡æ–°è®¤è¯†HashMap, \u003cem\u003eç¾å›¢æŠ€æœ¯å›¢é˜Ÿ\u003c/em\u003e, 2015. \u003ca href=\"https://tech.meituan.com/2016/06/24/java-hashmap.html\"\u003eğŸ“„\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eAniket Thakur, â€œWhy HashMap insert new Node on index (n - 1) \u0026#x26; hash?â€, \u003cem\u003eStack Overflow\u003c/em\u003e, 2017. \u003ca href=\"https://stackoverflow.com/a/44615382\"\u003eğŸ“„\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eJul, \"Why return (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16) other than key.hashcode?\", \u003cem\u003eStack Overflow\u003c/em\u003e, 2017. \u003ca href=\"https://stackoverflow.com/a/45140621\"\u003eğŸ“„\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eAndy Turner, \"HashMap.tableSizeFor(â€¦). How does this code round up to the next power of 2?\", \u003cem\u003eStack Overflow\u003c/em\u003e, 2018. \u003ca href=\"https://stackoverflow.com/a/51121765\"\u003eğŸ“„\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eMincong Huang, learning-hashmap, \u003cem\u003eMincong Huangâ€™s\u003c/em\u003e Blog, 2019. \u003ca href=\"https://mincong.io/2018/04/08/learning-hashmap/\"\u003eğŸ“„\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eé£æ±¡ç†Šåšå®¢, Javaå¾®åŸºå‡†æµ‹è¯•æ¡†æ¶JMH, \u003cem\u003eé£æ±¡ç†Šåšå®¢â€™s\u003c/em\u003e Blog, 2018. \u003ca href=\"https://www.xncoding.com/2018/01/07/java/jmh.html\"\u003eğŸ“„\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eJakob Jenkov, JMH - Java Microbenchmark Harness, \u003cem\u003eJakob Jenkov's\u003c/em\u003e Blog, 2015. \u003ca href=\"http://tutorials.jenkov.com/java-performance/jmh.html\"\u003eğŸ“„\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ejhm samples. \u003ca href=\"https://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/\"\u003eğŸ“„\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"java-hash-map"},"buildId":"pGGBVmnLCT4XKOq0_CdKw","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"name":"viewport","content":"width=device-width"}],["meta",{"charSet":"utf-8"}],["title",{"children":"HashMapåŸç†ç®€æ - kiyak"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-577caaa53936537aa4bf.js"></script><script src="/_next/static/chunks/main-9e14e9299d96e4a63fc3.js" async=""></script><script src="/_next/static/chunks/webpack-d7b2fb72fb7257504a38.js" async=""></script><script src="/_next/static/chunks/7af46002.7b37a38a8911fc5fb44b.js" async=""></script><script src="/_next/static/chunks/7658eb265201359a3f9e5f36a5d51cd74c781bde.716fe7386381de1064b0.js" async=""></script><script src="/_next/static/chunks/189f372a1a09b44bc5ee9e8694cd22967121ee9f.c1299753f6cf9d140411.js" async=""></script><script src="/_next/static/chunks/189f372a1a09b44bc5ee9e8694cd22967121ee9f_CSS.8f6f5b95f5e92b2c9bcd.js" async=""></script><script src="/_next/static/chunks/712a84a73acf62bf26290958298b2566586e7dd8_CSS.bca366718f045dbe8189.js" async=""></script><script src="/_next/static/chunks/93b2fd6e127d30331b61cfd2f04634ca05024a66_CSS.19830e50427f38e47434.js" async=""></script><script src="/_next/static/chunks/608d37238a334f4b11fe8d600201fe11b7a5b804.cbf6dda1e316f22fd86b.js" async=""></script><script src="/_next/static/chunks/d111f78934af154ae2b78def2cd48076645f6685.b41fcd8fbee89b9b32b6.js" async=""></script><script src="/_next/static/chunks/e70a2e0268e458e8b9abc18785a5727107407f8e.3f5af21948b0ca66102f.js" async=""></script><script src="/_next/static/chunks/styles.97cfe1edb1cdc49560a5.js" async=""></script><script src="/_next/static/chunks/pages/_app-307ac3bfcacd4d7be388.js" async=""></script><script src="/_next/static/chunks/8a4b9c7b11a9228b425c7a73cade1154f2ca061e.4a1b4be1a94f0b02499c.js" async=""></script><script src="/_next/static/chunks/8a4b9c7b11a9228b425c7a73cade1154f2ca061e_CSS.4d62413f4da81be1e932.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-c6ffa8c08f20ac6ea580.js" async=""></script><script src="/_next/static/pGGBVmnLCT4XKOq0_CdKw/_buildManifest.js" async=""></script><script src="/_next/static/pGGBVmnLCT4XKOq0_CdKw/_ssgManifest.js" async=""></script></body></html>