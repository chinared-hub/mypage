{"pageProps":{"post":{"filename":"programming/[Git]操作实践.md","title":"Git操作实践","excerpt":"","date":"2020-05-28T18:00:00.000Z","updated":"2020-05-28T18:00:00.000Z","preText":"Git","preTextColor":"#FF6666","content":"<h1>Git操作实践</h1>\n<h2>速览</h2>\n<h3>仓库</h3>\n<pre><code class=\"language-shell\"># 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n</code></pre>\n<h3>配置</h3>\n<pre><code class=\"language-shell\"># 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n</code></pre>\n<h3>增加/删除文件</h3>\n<pre><code class=\"language-shell\"># 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n</code></pre>\n<h3>代码提交</h3>\n<pre><code class=\"language-shell\"># 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n</code></pre>\n<h3>分支</h3>\n<pre><code class=\"language-shell\"># 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n</code></pre>\n<h3>标签</h3>\n<pre><code class=\"language-shell\"># 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n</code></pre>\n<h3>查看信息</h3>\n<pre><code class=\"language-shell\"># 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n</code></pre>\n<h3>远程同步</h3>\n<pre><code class=\"language-shell\"># 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n</code></pre>\n<h3>撤销</h3>\n<pre><code class=\"language-shell\"># 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n</code></pre>\n<h3>其他</h3>\n<pre><code class=\"language-shell\"># 生成一个可供发布的压缩包\n$ git archive\n</code></pre>\n<h2>设置Git用户名</h2>\n<p>在 Git 中设置自己的用户名是非常必要的一个步骤，因为在提交代码的时候，会记录下提交者的信息，这样就可以很清晰的看到某时某刻是谁推送了代码。</p>\n<p><strong>为一个仓库设置 Git 用户名</strong></p>\n<ol>\n<li>\n<p>打开 Git Bash。</p>\n</li>\n<li>\n<p>将当前工作目录更改为您想要在其中配置与 Git 提交关联的名称的本地仓库。</p>\n</li>\n<li>\n<p>设置 Git 用户名以及联系方式：</p>\n<pre><code class=\"language-shell\">$ git config user.name \"Mona Lisa\"\n$ git config user.email \"email@example.com\"\n</code></pre>\n</li>\n<li>\n<p>确认您正确设置了 Git 用户名以及联系方式：</p>\n<pre><code class=\"language-shell\">$ git config user.name\n> Mona Lisa\n$ git config user.email\n> email@example.com\n</code></pre>\n</li>\n</ol>\n<p><strong>为计算机上的每个仓库设置 Git 用户名</strong></p>\n<ol>\n<li>\n<p>打开 Git Bash。</p>\n</li>\n<li>\n<p>设置 Git 用户名：</p>\n<pre><code class=\"language-shell\">$ git config --global user.name \"Mona Lisa\"\n$ git config --global user.email \"email@example.com\"\n</code></pre>\n</li>\n<li>\n<p>确认您正确设置了 Git 用户名：</p>\n<pre><code class=\"language-shell\">$ git config --global user.name\n>Mona Lisa\n$ git config --global user.email\n> email@example.com\n</code></pre>\n</li>\n</ol>\n<h2>获取代码 (Fetch、Pull)</h2>\n<p>如果我们有一个远程 Git 分支，例如 Github 上的一个 master 分支，那么远程分支可能有本地分支没有的提交！也许是另一个分支合并了，也许是你的同事推送了一个 BUG 的修复，等等。</p>\n<p>如果想要同步这些最新的提交，可以使用两种方式，一种是 <code>git fetch</code>，另一种是 <code>git pull</code>。</p>\n<p><code>git fetch</code> 会将远程数据下载至本地，不过也仅仅是下载至本地而已。<br>\n<code>git pull</code> 会将远程数据下载至本地，除此之外，它还将下载的数据与本地代码合并。</p>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/git-pull.gif?v=1\" alt=\"git-merge-dev.gif\"></p>\n<p>通常的，开发人员会使用 <code>git pull</code> 来获取远程 Git 仓库上的最新提交，以达到更新本地代码的目的。其实，<code>git pull</code> 命令行就相当于 <code>git fetch</code> + <code>git merge origin/master</code>。一般来说，更新代码，使用 <code>git pull</code> 就好了。</p>\n<h2>合并代码 (Merge)</h2>\n<p>合并代码分为两种方式：Fast-forward (--ff)、No-fast-foward (--no-ff)。在多分支的开发环境下，合并代码 (git merge) 也是较为常用的一个命令。</p>\n<p><strong>Fast-forward (--ff)</strong> </p>\n<p>假设 master 主干要合并 dev 分支上的更改，而 master 相对于 dev 来说没有任何变动，那么 git 会使用 Fast-forward 方式进行一次快速合并。该方式是 git 的“懒”操作，这样不需要 master 主干生成任何提交记录，仅需复用 dev 分支的提交记录即可。</p>\n<pre><code class=\"language-shell\">$ git merge dev\nUpdating 7173edd..7d959a2\nFast-forward\n README.md | 1 +\n 1 file changed, 1 insertion(+)\n$ git push\n</code></pre>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/git-merge-dev.gif?v=2\" alt=\"git-merge-dev.gif\"></p>\n<p><strong>No-fast-foward (--no-ff)</strong> </p>\n<p>假设 master 、dev 两个分支的开发是并行开展的，该情况下进行代码的合并，git 就会主动提示开发人员进行必要的 <strong>commit</strong> 操作，此时的 <code>git merge dev</code> 操作就相当于 <code>git merge --no-ff dev</code>。该情况下的提交记录会与上边的 <strong>Fast-forward (--ff)</strong> 有差异， 因为合并之后，会在 master 与 dev 顶端生成一个新的提交记录。</p>\n<pre><code class=\"language-sh\">$ git merge dev\n</code></pre>\n<pre><code class=\"language-sh\">Merge branch 'dev'\n# Please enter a commit message to explain why this merge is necessary,\n# especially if it merges an updated upstream into a topic branch.\n#\n# Lines starting with '#' will be ignored, and an empty message aborts\n# the commit.\n\n</code></pre>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/git-merge-no-ff-dev.gif?v=2\" alt=\"git-merge-no-ff-dev.gif\"></p>\n<h2>合并冲突 (Merge Conflicts)</h2>\n<p>合并代码发生冲突是很常见的场景，例如，在某两个分支中，对相同文件的相同位置做了不同的修改，该情况下合并代码，git 是无法自主决定代码的合并的，因为无法确定哪个分支的更改才是最有效的。</p>\n<p>假设有A、B程序员以及一个 README.md 文件<br>\nA 程序员：编辑 master 主干 README.md 里的第一行文字，更改为：Hey！<br>\nB 程序员：编辑 dev 分支 README.md 里的第一行文字，更改为：Hello！<br>\n此时合并代码将发生冲突：</p>\n<pre><code class=\"language-shell\">$ git merge dev\nAuto-merging README.md\nCONFLICT (content): Merge conflict in README.md\nAutomatic merge failed; fix conflicts and then commit the result.\n</code></pre>\n<p>该情况下需要人为的解决冲突，首先编辑 README.md 文件：</p>\n<pre><code class=\"language-shell\">vi README.md\n</code></pre>\n<p>可以发现 README.md 的内容会有所更改，因为 git 自动填充了两个分支的不同之处，以方便开发人员进行比较，如下所示：</p>\n<pre><code class=\"language-shell\">&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C;&#x3C; HEAD\nHey！\n=======\nHello！\n>>>>>>> dev\n</code></pre>\n<p>此时只需决定需要保留的内容即可，如保留 <code>Hey！</code>而非 <code>Hello！</code>：</p>\n<pre><code class=\"language-shell\">Hey！\n</code></pre>\n<p>最后重新提交代码即可，本次合并的冲突就解决啦。</p>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/git-merge-conflicts.gif?v=3\" alt=\"git-merge-comflicts.gif\"></p>\n<h2>变基 (Rebase)</h2>\n<p>在之前的操作中可以了解到，<code>git merge</code> 可将更改从一个分支应用于另一个分支。而 git 还有一种类似的操作 <code>git rebase</code>，也可实现将更改从一个分支添加到另一个分支。</p>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/git-rebase.gif?v=3\" alt=\"git-rebase.gif\"></p>\n<p>如上图所示， <code>git rebase</code> 不同于 <code>git merge</code> 之处，在于 rebase 会重写提交树的结构，以使 master 分支成为当前分支的一部分。</p>\n<p>个人理解：使用 rebase ，可以使得当前开发的分支是基于 master 或者其他重要分支进行延伸，而如果当前分支的代码要被 master 或其它分支合并时，可以顺利的完成一次 (Fast-forward) 合并！</p>\n<h2>恢复 (Reset、Revert)</h2>\n<p>如果在开发过程中对代码做了不理想的更改，比如存在 BUG、功能调整等，那么在推送代码之前，我们还是可以对这些文件内容或者状态进行回滚、恢复、重新编辑等。</p>\n<p><strong>Soft reset</strong></p>\n<p>假设在本地的 dev 分支分别提交了 style.css 和 index.js 文件的更改，生成了两条记录 <strong>change background-color</strong>、<strong>fixed index logic</strong>，如下图所示：</p>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/git-reset-test.png\" alt=\"git-reset-test\"></p>\n<p>查看当前 git 的状态：</p>\n<pre><code class=\"language-shell\">$ git status\nOn branch dev\nYour branch is ahead of 'origin/dev' by 2 commits.\n  (use \"git push\" to publish your local commits)\n</code></pre>\n<p>如果想要撤销这两次提交记录，但是需要保留当前更改的内容，那么可以通过执行 <code>git reset --soft HEAD~2</code> 来实现 (<em>HEAD 指针后退两步</em> )。此时观察 git 状态，会显示 index.js、style.css 都处于 <strong>modified</strong> 状态，等待着新的 <strong>commit</strong> (<em>Changes to be committed</em>)。</p>\n<pre><code class=\"language-shell\">$ git status\nOn branch dev\nYour branch is up to date with 'origin/dev'.\n\nChanges to be committed:\n  (use \"git reset HEAD &#x3C;file>...\" to unstage)\n\n        modified:   index.js\n        modified:   style.css\n</code></pre>\n<p>相应的，git 的历史记录也有所改变：</p>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/git-reset-test-2.png\" alt=\"git-reset-test-2\"></p>\n<p><strong>Mixed reset</strong></p>\n<p>与 <code>reset --soft</code> 效果一致，唯一不同的是 <code>reset --mixed</code> 会将本地暂存区的缓存删掉。</p>\n<pre><code class=\"language-shell\">$ git reset --mixed HEAD~2\nUnstaged changes after reset:\nM       index.js\nM       style.css\n</code></pre>\n<p>所以如果要重新 <code>commit</code> 文件，需要先对文件进行 <code>git add</code> 操作。</p>\n<p><strong>Hard reset</strong></p>\n<p><code>reset --hard</code> 命令相对更加的严格，使用 <strong>hard</strong> 不仅会删除本地暂存区的缓存，还会将实际编辑的文件也一并恢复原样。</p>\n<pre><code class=\"language-shell\">$ git reset --hard HEAD~2\nHEAD is now at 431f5f6 fixed something\n</code></pre>\n<pre><code class=\"language-shell\">$ git status\nOn branch dev\nYour branch is up to date with 'origin/dev'.\n\nnothing to commit, working tree clean\n</code></pre>\n<p>观察文件可以看到，文件恢复成了更改前的模样，就好像什么都没发生过。</p>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/git-reset-test-3.png\" alt=\"git-reset-test-3\"></p>\n<p><strong>revert</strong></p>\n<p>git 提供的另一个命令 <strong>revert</strong> 也可以实现代码的回退。与 <strong>reset</strong> 命令不一样，revert 不会删除暂存区数据、也不会回退 <strong>HEAD</strong> 指针，相反，revert 会要求新增对应的 commit ，来加以说明为什么要对文件进行恢复或者回退操作。</p>\n<p>比如需要回滚以上 index.js 、style.css 两个文件的代码并且记录下原因，那么可以使用 <code>git revert HEAD~2..</code> 来实现。</p>\n<p>查看 git 的历史记录：</p>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/git-reset-test-4.png\" alt=\"git-reset-test-3\"></p>\n<pre><code class=\"language-shell\">git revert HEAD #撤销最新提交\ngit revert HEAD^ #撤销倒数第2次提交\ngit revert HEAD~2 #撤销倒数第3次提交\ngit revert HEAD~2.. #撤销最新两次提交\ngit revert commit-id #撤销指定的 commit-id\n</code></pre>\n<h1>参考资料</h1>\n<ul>\n<li>GitHub, 在 Git 中设置用户名, <em>GitHub help</em>. <a href=\"https://help.github.com/cn/github/using-git/setting-your-username-in-git\">📄</a></li>\n<li>阮一峰, 常用 Git 命令清单, <em>阮一峰的网络日志</em>, 2015. <a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\">📄</a></li>\n<li>Rob Di Marco, Peter Mortensen, “When do you use Git rebase instead of Git merge?”, <em>Stack Overflow</em>, 2019. <a href=\"https://stackoverflow.com/a/804156\">📄</a></li>\n<li>Lydia Hallie, 🌳🚀 CS Visualized: Useful Git Commands, <em>DEV</em>, 2020. <a href=\"https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1\">📄</a></li>\n<li>GitHowTo. <a href=\"https://githowto.com\">📄</a></li>\n</ul>\n"}},"__N_SSG":true}