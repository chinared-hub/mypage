{"pageProps":{"post":{"filename":"个人网站开发实践.md","title":"个人网站开发实践","excerpt":"记录下一些开发内容或者优化心得","date":"2019-01-20T18:35:07.322Z","updated":"2020-05-26T14:02:00.000Z","preText":"👍","preTextColor":"#ffddbb","content":"<h1>个人网站开发实践</h1>\n<p>必备：<a href=\"https://nodejs.org/en/\">NodeJs</a> 、<a href=\"http://nginx.org/en/download.html\">Nginx</a></p>\n<h2>使用Next.js</h2>\n<p>网站的开发采用 <strong><a href=\"https://nextjs.org/\">Next.js</a></strong>，Next.js 具有自动代码拆分、预渲染、基于文件系统路由等等便利于开发的特性 ☕</p>\n<p>官方在 Github 上列出了许多例子 👉 <a href=\"https://github.com/zeit/next.js/tree/canary/examples\">example</a> ，以 <a href=\"https://github.com/zeit/next.js/tree/canary/examples/with-ant-design-less\">with-ant-design-less</a> 为例，在 cmd 面板下运行以下命令</p>\n<pre><code class=\"language-sh\">npm init next-app --example with-ant-design-less projectname\nnpm install\nnpm run dev\n</code></pre>\n<p>访问 <a href=\"http://localhost:3000/\">http://localhost:3000</a>，可以看到如下页面：</p>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/welcome-to-nextjs.png\" alt=\"Welcome to Next.js\">\n<small style='text-align: center'>图片来自Next.js官网</small></p>\n<h2>使用nginx的gzip压缩功能</h2>\n<p>为了加快访问网站的速度，必须将网站的 js、css、html等文件尽量变得足够小，网络的传输才能足够快</p>\n<p>首先使用 webpack 可视化分析插件： <a href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\">webpack-bundle-analyzer</a> ，并且构建已有项目：<code>npm run build</code><br>\n构建将产生的文件一一罗列并且生成依赖关系图，效果如下：</p>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/webpack-analysis-1.png\" alt=\"img\"></p>\n<p>观察构建的文件大小，以 9c3bc3cde28db290887b7e6d1f1907160b18de5e.547bf9fb904ff2a9c3bc.js 为例，大小为 123.61kb，在网络传输中，100+kb算是可以接受的大小了，但幸运的是，还能做到更小！</p>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/webpack-analysis-2.png\" alt=\"img\"></p>\n<p>nginx 提供了一个开箱即用的压缩功能 <strong>gzip</strong>，但默认情况下，gzip 设置是不开启的，在官网下载的 nginx 里，nginx.conf 文件会有这一行代码：</p>\n<pre><code class=\"language-nginx\">#gzip on;\n</code></pre>\n<p>此时对 gzip 功能不做任何变动，将构建好的静态项目放入 nginx 并且启动本地服务。打开网页，搜索文件名称 9c3bc3cde28db290887b7e6d1f1907160b18de5e.547bf9fb904ff2a9c3bc.js</p>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/9c3bc3cde28db290887b7e6d1f1907160b18de5e.547bf9fb904ff2a9c3bc.png\" alt=\"img\"></p>\n<p>可以看到文件传输的大小为：127kb (左下角 - transferred)</p>\n<p>重新打开 nginx.conf 文件并且编辑如下内容：</p>\n<pre><code class=\"language-nginx\">#开启gzip压缩\ngzip on;\n#压缩级别1~9，值越大压缩越好，但耗费越多CPU资源\ngzip_comp_level 1;\n#文件大于1k才进行压缩\ngzip_min_length 1k;\n#gz后缀文件不压缩\ngzip_static off;\n#是否在http header中添加Vary: Accept-Encoding\ngzip_vary on;\n#指定压缩的文件类型\ngzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript;\n#指定压缩缓冲大小\ngzip_buffers 2 4k;\n</code></pre>\n<p>保存之后重新启动 nginx：<code>nginx -s reload</code>，再次访问网页</p>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/9c3bc3cde28db290887b7e6d1f1907160b18de5e.547bf9fb904ff2a9c3bc-2.png\" alt=\"img\"></p>\n<p>响应头增加了 <code>Content-Encoding: gzip</code>，文件也减小了，变成41.6kb！</p>\n<h2>使用nginx缓存</h2>\n<p>同样在 nginx.conf 文件里增加如下内容，重启 nginx</p>\n<pre><code class=\"language-nginx\">#图片缓存时间设置\nlocation ~* \\.(gif|jpg|jpeg|png|bmp|swf|ico)$ {\n    expires 24h;\n    add_header Cache-Control \"public\";\n}\n#JS和CSS缓存时间设置\nlocation ~* \\.(js|css)$ {\n    expires 24h;\n    add_header Cache-Control \"public\";\n}\n</code></pre>\n<p>重新查看请求的响应头会多出一行指令： <strong>Cache-Control: max-age=86400</strong>，这可以告诉客户端将文件存到本地，在某段时间内(86400s)都将使用本地文件，而不是每次都去请求服务器。可减缓服务压力，同时提高页面响应速度</p>\n<h2>使用compression-webpack-plugin插件</h2>\n<blockquote>\n<p>Prepare compressed versions of assets to serve them with Content-Encoding.</p>\n</blockquote>\n<p>该插件可将 webpack 构建生成的文件进行 gzip 压缩，生成对应的 gz 文件</p>\n<p>例如 webpack 构建并且生成文件：</p>\n<p>xxx.js - 80kb</p>\n<hr>\n<p>使用了 compression-webpack-plugin 插件之后：</p>\n<p>xxx.js - 80kb</p>\n<p>xxx.js.gz - 3kb</p>\n<hr>\n<p>该做法旨在提前将文件进行压缩，在推送到服务器之后可直接使用压缩好的 gz 文件，而不是使用服务器的 CPU 资源进行文件的压缩操作。要想 nginx 能够直接利用 gz 文件，需要开启 gzip_static 功能。</p>\n<pre><code class=\"language-nginx\">gzip_static on;\n</code></pre>\n<h2>部署</h2>\n<p>采用 Jenkins 、Git、Docker 实现快速的版本迭代更新。</p>\n<p><img src=\"https://resource.1024kb.top/image/code-sample/CI&#x26;CD.png?v=2\" alt=\"img\"></p>\n<p>思路：</p>\n<ol>\n<li>将本地开发的代码提交 github </li>\n<li>启动 Jenkins 流水线<ol>\n<li>拉取最新代码：git pull</li>\n<li>下载依赖： npm i</li>\n<li>构建项目：npm run build</li>\n<li>打包必要文件：nginx.conf、start.sh<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup> 、Dockerfile、out<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></li>\n</ol></li>\n<li>将打包好的文件发布到 Cenos 服务器，执行 start.sh</li>\n<li>Docker 生成 nginx 镜像，根据镜像构建一个 Docker 容器，并将 nginx.conf、out 文件放入容器指定的位置</li>\n</ol>\n<p>start.sh</p>\n<pre><code class=\"language-sh\">#!/bin/bash\nBASE_PATH=/kiyak/kiyak-web\nSERVER_NAME=kiyak-web\nKIYAK_CONTAINER=$(docker ps -a | grep \"${SERVER_NAME}\" | awk '{print $1}')\nKIYAK_IMAGE=$(docker images | grep \"${SERVER_NAME}\" | awk '{print $3}')\nKIYAK_NET_WORK=snail-net\n\n# 构建docker镜像\nif [ -n \"$KIYAK_CONTAINER\" ]\nthen\n  echo \"存在$SERVER_NAME容器，ID=$KIYAK_CONTAINER\"\n  echo \"停止$SERVER_NAME容器，ID=$KIYAK_CONTAINER\"\n  docker stop $KIYAK_CONTAINER\n  echo \"删除$SERVER_NAME容器，ID=$KIYAK_CONTAINER\"\n  docker rm $KIYAK_CONTAINER\nfi\n\nif [ -n \"$KIYAK_IMAGE\" ]\nthen\n  echo \"存在$SERVER_NAME镜像，ID=$KIYAK_IMAGE\"\n  echo \"删除$SERVER_NAME镜像，ID=$KIYAK_IMAGE\"\n  docker image rm $KIYAK_IMAGE\nfi\n\ncd $BASE_PATH\necho \"创建$SERVER_NAME镜像......\"\ndocker build -t $SERVER_NAME .\necho \"启动$SERVER_NAME容器......\"\ndocker run --name $SERVER_NAME -u root -p 80:80 -p 443:443 -v /etc/localtime:/etc/localtime:ro -v /kiyak/web-log:/etc/nginx/logs --network $KIYAK_NET_WORK -d $SERVER_NAME\n\n# 清理文件\nrm -rf $BASE_PATH/*\n</code></pre>\n<p>Dockerfile</p>\n<pre><code class=\"language-markdown\">FROM nginx\nEXPOSE 80 443\nADD kiyak-web.tar.gz /etc/nginx/kiyak-web/\nADD cert.tar.gz /etc/nginx/\nCOPY nginx.conf /etc/nginx/nginx.conf\n</code></pre>\n<h1>参考资料</h1>\n<ul>\n<li>Jeff Posnick, Ilya Grigorik, Prevent unnecessary network requests with the HTTP Cache, <em>web.dev</em>, 2020. <a href=\"https://web.dev/http-cache/\">📄</a></li>\n<li>Marc Novakowski, Oliver Weichhold, “ETag vs Header Expires”, <em>Stack Overflow</em>, 2014 <a href=\"https://stackoverflow.com/a/500103\">📄</a></li>\n</ul>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">Shell 脚本，主要集成操作 docker 的各种命令行<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a></li>\n<li id=\"fn-2\">webpack 构建生成的文件夹，里面包含项目的所有静态文件：js、css、html<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a></li>\n</ol>\n</div>\n"}},"__N_SSG":true}